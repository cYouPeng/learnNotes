第一章
	一个完整的JavaScript应包含 ECMAScript(核心)、DOM(文档对象模型)、BOM(浏览器对象模型)

第二章
	<script>元素如果没有指定type属性，则其默认值为type/javascript
	<script>元素有两种使用方式：直接在页面中嵌入js代码和包含外部js文件。但不管使用哪一种方式，在下载解析执行js代码时，页面的处理会暂时停止，也就是说会造成阻塞
	如果<script>用来引入外部js文件，则<script>和</script>标签之间就不能再包含额外的js代码，如果包含，则会被忽略
	<script>的src属性还可以包含外部域的js文件，也就是说src的值可以是互联网中的某个js文件的完整的url，但此时要小心使用该文件，以免某些心怀恶意的程序员
	如果页面中有多个<script></script>，浏览器会按照先后顺序对其进行解析，只有在前一个<script>解析完成后，才会解析下一个<script>
	<script>标签要放在<body>元素中内容的后面，这样可以先显示页面内容，而不会造成在下载解析执行js代码时页面的空白
	<body>
		<!-- 这里放内容 -->
		<script type="text/javascript" src="example.js"></script>
		<script type="text/javascript" src="example2.js"></script>
	</body>
	嵌入代码与外部文件，最好使用外部文件，有如下优点
	1，可维护性：每个html页面都放一份相同的js代码维护起来很麻烦，但把这些js代码放到一个文件中，维护起来就很方便。而且也不必触及到html代码，可集中精力编写js
	2，可缓存，浏览器可以根据设置缓存外部js文件，也就是说如果有两个页面都使用同一个文件，那么这个文件只需下载一次，能够提高页面加载的速度
	
第三章
	1，ECMAScript中的一切都区分大小写
	2，所谓标识符，就是指变量、函数、属性的名字，或者函数的参数
		第一个字符必须是一个字母、下划线、或者是$
		其它字符可以是字母、下划线、$或数字
	标识符最好采用驼峰大小写格式，也就是第一个字母小写，剩下每个单词的首字母大写
	不能把关键字、保留字、true、false、和null用做标识符
	3，ECMAScript使用C风格的注释，包括单行注释和块级注释
		单行注释以两个斜杠开头：// 内容
		块级注释以一个斜杠和一个星号开头，以一个星号和一个斜杠结尾：
		/*
		 *  内容  中间的星号是为了提高可读性
		 */
	4，ECMAScript 5引入了严格模式(strict mode)的概念。严格模式是为JavaScript定义了一种不同的解析与执行模型，ECMAScript 3中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码：
	"use strict"
	它是一个编译指示，用于告诉支持JavaScript的引擎切换到严格模式。这是为不破坏 ECMAScript 3 语法而特意选定的语法
	在函数内部上方包含这条编译指示，也可以指定函数在严格模式下执行
	function doSomething(){
		"use strict";
		//函数体
	}
	严格模式下，JavaScript的执行结果会有很大不同。
	支持严格模式的浏览器包括 IE10+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome
		 
	5，语句结尾的分号以及控制语句的大括号不要省略，尽管这不会报错，但为了可维护和提高性能
	6，关键字和保留字
	7，ECMAScript的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已
		定义变量时使用var操作符后跟变量名
		var message;
		该变量可以用来保存任何值，像这样未经过初始化的变量，会保存一个特殊的值-undefined
		也可以在声明变量的同时进行初始化
		var message = "hi";
		message = 100;   在修改值的同时修改值的类型，这种操作虽然在ECMAScript中完全有效，但不推荐这样做
		
		在函数中使用var定义一个变量，在函数被调用时，就会创建该变量并为其赋值，调用结束后，该变量立即被销毁
		function test(){
			var message = ""hi;
		}
		test();
		alert(message);  //错误
		
		如果像下面这样省略var操作符，可以创建一个全局变量
		function test(){
			message = "hi";
		}
		test();
		alert(message); // "hi"   message成了全局变量
		但我们不推荐这种做法，这样的全局变量很难维护，并且在严格模式下，给未经声明的变量赋值会抛出ReferenceError
		
		因为是松散类型的，所以不同类型初始化可以放在一条语句中完成
		var message = "hi",
			found = false,
			age = 29;         //换行和缩进可以提高可读性
			
		在严格模式下，不能定义名为eval 或 arguments的变量，否则会报语法错误。但非严格模式下正常执行
		
	8，ECMAScript有6种数据类型，其中5种基本数据类型：Undefined、Null、Boolean、Number、String
								1种引用数据类型：Object
		鉴于ECMAScript是松散类型的，因此需要有一种手段来检测给定变量的数据类型   typeof操作符
		对一个值使用typeof操作符可能返回下列某个字符串
		"undefined" -如果这个值未定义
		"boolean" -如果这个值是布尔值
		"string" -如果这个值是字符串
		"number" -如果这个值是数值
		"object" -如果这个值是对象或null
		"function" -如果这个值是函数
		
		var message = "some string";
		alert(typeof message); // "string"
		alert(typeof (message)); // "string"  typeof是操作符不是函数，但圆括号也可以使用，不是必需的
		alert(typeof 95); // "number"
		
		typeof操作符的操作数可以是变量，也可以是字面量。null被认为是一个空的对象引用，所以返回"object"
		 
	9,	Undefined类型只有一个值，即undefined
		在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined
		
		值为undefined的变量与尚未定义的变量还是不一样的
		var message;
		alert(message); //undefined
		alert(age); //报错
		对于尚未声明过的变量，只能执行一项操作，即使用typeof操作符检测其数据类型
		
		对未初始化和未声明的变量执行typeof操作符都会返回undefined，所以我们在声明变量时最好同时进行初始化，这样在以后进行typeof检测时，如果返回undefined，就可以知道该变量尚未声明，而不是尚未被初始化
		 
	10, Null类型只有一个值，即null，表示一个空对象指针
		有一点需要注意，undefined值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回true
		alert(null == undefined); //true
		尽管null和undefined有这样的关系，但他们的用途完全不同，如前所述，无论在什么情况下都没有必要把一个变量的值显式地设置为undefined，可是同样的规则对null却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值
		 
	11, Boolean类型是ECMAScript中使用最多的一种类型，该类型只有两个字面值：true 和 false
		这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0
		这两个值是区分大小写的，因此True和False以及其他混合大小写形式，都不是Boolean值，只是标识符
		虽然Boolean类型的字面值只有两个，但ECMAScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean()
		以下为转换规则：
			true 任何非空字符串 任何非零数字值(包括正负无穷大) 任何对象    都会转换为true
			false ""(空字符串) 0和NaN null undefined 都会转换为false
		熟记这些转换规则，对于流程控制语句中自动执行的Boolean转换非常重要
		var mssage = "hi";
		if(message) {
			alert(123);
		}
		/*
		 *	es是严格区分大小写的，因此Infinity和NaN  一定要注意大小写，一定是大写I后跟小写nfinity，一定是两个N中间夹一个小a
		 */
	12, Number类型
		最基本的数值字面量格式：十进制整数     var num = 44;
		八进制(以8为基数，第一位必须是0，注意是零，然后数字序列0~7，如果字面值中的某个数字超出了这个范围，那么前导0将被忽略，后面的数字当做是十进制处理)
		var num1 = 070   //八进制的56
		var num2 = 079   //无效的八进制数值--解析为79
		有一点需要注意，八进制在严格模式下是无效的，会报错
		
		十六进制(以16为基数，前两位必须是0x，注意是零和字母x(大小写都行)，后跟任何十六进制数字(0~9及A~F))
		var num3 = 0x1f  //十六进制的31
		
		在进行算术运算时，所有以八进制和十六进制表示的数值最终都将转换成十进制进行运算
		js中是可以保存正零(+0)和负零(-0)的，它俩被认为相等    console.log(0 == -0)  //true		
		所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法
		var floatNum1 = 1.1;
		var floatNum2 = .1  //有效，但不推荐
		
		由于保存浮点数值需要的内存空间是保存整数的两倍，所以 var num = 10.0; 10.0会被转换成整数10，所以console.log(num);
		输出10，而不是10.0。如果保存的是10.1的话，那么输出的就是10.1
		对于那些极大或极小的数值，可以用e表示法(即科学计数法)：即前面一个数值(可以是整数也可以是浮点数)，中间是一个大写或小写的字母E，后面是10的指数次幂，该幂值将用来与前面的数相乘
		var num = 3.125e7; //等于 31250000  3.125乘以10的7次幂
		
		在默认情况下，ECMAScript会将那些小数点后面带有6个零以上的浮点数值转换为以e表示法表示的数值，这指的是0.000000...
		var num = 0.0000003;
		console.log(num);  //3e-7  3乘以负的10的7次幂  
		浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1加0.2的结果不是0.3，而是0.30000000000000004。所以不要做这样的测试
		if(a + b == 0.3){
			alert("you got 0.3");
		}
		如果这两个数是0.05和0.25，或者是0.15和0.15都不会有问题，而如前所述，如果这两个数是0.1和0.2，那么测试将无法通过。因此，永远不要测试某个特定的浮点数值
		关于浮点数值计算会产生误差的问题，有一点需要明确：这是使用基于IEEE754数值的浮点计算的通病，ECMAScript并非独此一家；其它使用相同数值格式的语言也存在这个问题
		
		ECMAScript能够表示的最小数值保存在 Number.MIN_VALUE 中，在大多数浏览器中，这个值是 5e-324    
		能够表示的最大数值保存在 Number.MAX_VALUE 中-在大多数浏览器中，这个值是 1.7976931348623157e+308
		如果某次计算的结果得到了一个超出JavaScript数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具体来说，如果这个数值是负数，则会被转换成 -Infinity (负无穷)，如果这个数值是正数，则会被转换成 Infinity (正无穷)
		console.log(typeof Infinity);  // "number"
		
												注意严格区分大小写
		
		如果某次计算返回了正或负的Infinity值，那么该值将无法继续参与下一次的计算，因为Infinity不是能够参与计算的数值。
		要想确定一个数值是不是有穷的(换句话说，是不是位于最小和最大的数值之间)，可以使用 isFinite() 函数。这个函数在参数位于最小与最大数值之间时会返回true
		var res = Number.MAX_VALUE + Number.MAX_VALUE;
		console.log(isFinite(res));  //false
		尽管在计算中很少出现某些值超出表示范围的情况，但在执行极小或极大数值的计算时，对这些值进行检测是很有必要的
		
		访问 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以得到负和正的 Infinity 值
		
		NaN，即非数值(Not a Number)，是一个特殊的数值，用于表示一个本来要返回数值的操作数未返回数值的情况
		在其它编程语言中，任何数值除以非数值都会导致错误，从而停止代码执行。但在ECMAScript中，任何数值除以非数值会返回NaN，因此不会影响其它代码的执行
		NaN本身有两个特点：
			任何涉及NaN的操作都会返回NaN   NaN/10   -> NaN
			NaN与任何值都不相等，包括NaN本身  console.log(NaN == NaN);  //false
		isNaN()函数接受一个参数，该参数可以是任何类型，而函数可以帮助我们确定这个参数是否"不是数值"。它在接收到一个值之后，会尝试将这个值转换为数值，能转换成数值会返回false，不能转换成数值会返回true
		console.log(isNaN(NaN));  //true
		console.log(isNaN(10));  //false (10是一个数值)
		console.log(isNaN("10"));  //false (可以被转换成数值10)
		console.log(isNaN("blue"));  //true (不能转换成数值)
		console.log(isNaN(true));  //false (可以被转换成数值1)
		
		有三个函数可以把非数值转换为数值：Number(),parseInt(),parseFloat()
		第一个函数转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值
		Number函数的转换规则如下：
			如果是Boolean值，true和false将分别被转换为1和0
			如果是数字值，那还是数字值了
			如果是null值，转成0
			如果是undefined，转成NaN
			如果是字符串：
				如果字符串只包含数字，则转换成十进制数值
				如果只包含浮点格式，则转换成浮点数值
				如果只包含十六进制格式，则转换成对应的十进制
				如果只是空串，则转换成0
				如果包含上述格式之外的字符，则转换成NaN   
				
				console.log(Number("33abc"))  //NaN
				console.log(Number("0023"))  //23     转换过程中会忽略掉前导0
				
		由于Number()函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是parseInt()函数
		parseInt()会忽略字符串前面的空格，直至找到第一个非空格字符。如果这个非空格字符不是数字字符或负号，直接返回NaN，也就是说parseInt()转换空串会返回NaN，这一点和Number()函数是不一样的
		如果这个非空格字符是数字字符或负号，则继续向下解析，直到解析完所有后续字符或者遇到了一个非数字字符
		console.log(parseInt("   33abc"))  //33
		
		如果字符串以"0x"开头且后跟数字字符，就会将其当做一个十六进制整数
		如果字符串以"0"开头且后跟数字字符，就会将其当做一个八进制整数
		console.log(parseInt("0xA")); //10
		console.log(parseInt("070")); //56
		
		但是在解析八进制字面量的字符串时，ECMAScript 3 和 ECMAScript 5存在着分歧：
		3 认为上述这个 "070" 是八进制    所以输出56
		5 认为它是十进制                 所以输出70   我的浏览器上是70
		
		要解决这个分歧，可以借助parseInt()的第二个参数：转换时使用的基数(即多少进制)
		parseInt("070", 8)   //56
		parseInt("70", 8)	 //56
		
		parseInt("0xAF", 16)  //175
		parseInt("AF", 16)    //175	
		parseInt("AF")        //NaN
		
		如果指定了第二个参数，那么八进制和十六进制开头需要的 0 和 0x 就可以省略掉了。但如果没有指定，你要省略的话，看上面...
		 
		指定基数会影响到转换的输出结果
		parseInt("10", 2);   //2 (按二进制解析)
		parseInt("10", 8);   //8 (按八进制解析)
		parseInt("10", 10);  //10 (按十进制解析)
		parseInt("10", 16);  //16 (按十六进制解析)    
		parseInt("110", 16); //272  1*16^2 + 1*16^1 + 0*16^0
		不指定基数意味着让parseInt()自己决定，因此为了避免错误的解析，我们应该无论什么情况下都明确指定基数
		在大多数情况下，十进制使用最多，因此始终将10作为第二个参数是很有必要的
		
		parseFloat()的第一个小数点是有效的，而第二个小数点就是无效的了
		parseFloat()始终都会忽略掉前导的0    八进制会被当成十进制
		十六进制格式的字符串始终会被转换成0
		它只解析十进制，因此它没有用第二个参数指定基数的用法
		如果遇到的是一个可解析为整数的字符串(没有小数点或小数点后全是0)，parseFloat()会返回整数
		parseFloat("23.34.56"); //23.34
		parseFloat("0xF"); //0
		parseFloat("70.0000"); //70
		parseFloat("3.125e7"); //31250000
		
	13, String类型用于表示由零个或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号或单引号表示，这两种表示的字符串完全相同，全凭你意愿
	
		String数据类型包含一些特殊的字符字面量，也叫转义序列
		\n 换行
		\t 制表
		\b 退格
		\r 回车
		\\ 斜杠
		\' 单引号
		\" 双引号
		\xnn 以十六进制代码nn表示的一个字符(其中n为0~F)。例如，\x41表示"A"
		\unnnn 以十六进制代码nnnn表示的一个Unicode字符(其中n为0~F)。例如，\u03a3表示希腊字符
		这些字符字面量可以出现在字符串中的任意位置，而且也将被作为一个字符来解析
		var text = "hello \u03a3";  //这个例子中变量text有12个字符，其中6个字符长的转义序列表示1个字符
		
		任何字符串的长度都可以通过访问其length属性取得
			console.log(text.length);  //12
			
		ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，
		首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量
		var lang = "Java";
		lang = lang + "Script";
		以上示例中的变量lang开始时包含字符串"Java"。而第二行代码把lang的值重新定义为"Java"与"Script"的组合，即"JavaScript"。
		实现这个操作的过程如下：首先创建一个能容纳10个字符的新字符串，然后在这个字符串中填充"Java"和"Script"，最后一步是销毁
		原来的字符串"Java"和字符串"Script"因为这两个字符串已经没用了。这个过程是在后台发生的，而这也是在某些旧版本的浏览器(
		例如版本低于1.0的Firefox、IE6等)中拼接字符串时速度很慢的原因所在。但这些浏览器后来的版本已经解决了这个低效率问题
		 
		要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的toString()方法。这个方法唯一要做的就是返回相应值
		的字符串表现		
		var age = true;
		console.log(age.toString());  //"true"
		
		数值、布尔值、对象和字符串值(没错，每个字符串也都有一个toString()方法，该方法返回字符串的一个副本)都有toString()方法，
		但null和undefined值没有这个方法。
		多数情况下，调用toString方法不必传递参数。但是，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数。
		默认情况下，toString()以十进制格式返回数值的字符串表现。而通过这个参数，你可以指定二进制、八进制、十六进制，乃至其它
		任意有效进制
		var num = 10;
		num.toString(2); //"10" 二进制数值的字符串
		num.toString(8); //"12" 八
		num.toString();  //10 如果你不传参数，默认返回十进制下的字符串表现
		
		还有一种方式是转型函数String()，这个函数能够将任何类型的值转换为字符串，转换规则如下：
			如果值有toString()方法，则调用该方法(没有参数)并返回相应的结果
			如果值是null，则返回"null"
			如果值是undefined，则返回"undefined"
			String(null)  //"null"
			String(true)  //"true"
			
		其实还有一种，要把某个值转换为字符串，可以使用加号操作符把它与一个字符串("")加在一起
		
		
	14, Object类型
		var o = new Object();
				new Object;  //如果不给构造函数传递参数，则可以省略小括号，但不推荐这样做
		仅仅创建Object的实例并没有什么用处，但关键是要理解一个重要的思想：即在ECMAScipt中，(就像Java中的java.lang.Object 对象一样)Object类型是所有它的实例的基础。换句话说，Object类型所具有的的任何属性和方法也同样存在于更具体的对象中
		
		Object的每个实例都具有下列属性和方法
			constructor: 保存着用于创建当前对象的函数。对前面例子而言，构造函数就是Object()
			hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中(而不是在实例的原型中)是否存在。其中，作为参数的
			的属性名必须以字符串形式指定
			o.hasOwnProperty("name")
			
			isPrototypeOf(object): 用于检查传入的对象是否是当前对象的原型
			propertyIsEnumerable(propertyName): 用于检查给定的属性是否能够使用for-in语句来枚举。同样，作为参数的
			的属性名必须以字符串形式指定
			
			toLocaleString(): 返回对象的字符串表示，该字符串与执行环境的地区对应
			toString(): 返回对象的字符串表示
			valueOf(): 返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同
			
		由于在ECMAScript中Object是所有对象的基础，因此所有对象都具有这些基本的属性和方法
		
3.5.1 一元操作符
	1，递增和递减操作符
		分为前置型和后置型
		前置递增和递减操作是在包含它们的语句被求值之前执行的。。也就是先执行递增或递减，然后再语句求值
		var age = 20;
		var newAge = --age + 2;  // 先执行 --age  在执行 age + 2   所以newAge 等于 21
		
		后置递增和递减操作是在包含它们的语句被求值之后执行的。。也就是先执行语句求值，然后再递增或递减
		var age = 20;
		var newAge = age++ + 2;  //先执行age + 2 在执行age++  所以newAge等于22
		
		这四个操作符不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象。其规则如下：
			在应用于一个包含有效数字字符的字符串时，先将其转换成数字值，再自增或自减。同时这个字符串也变成了数值，从String类型变成了Number类型
			在应用于一个不包含有效数字字符的字符串时，将其值转换成NaN，字符串也从String类型变成了Number类型
			在应用于true或false，先将其转换成1或0，再自增或自减。布尔值也从Boolean变成了Number
			在应用于对象时，先调用对象的valueOf()方法，以取得一个可供操作的值，然后对该值应用上述规则。如果结果是NaN，则再调用
			toString()取得一个值，在应用上述规则。对象从Object变成Number
			var s1 = "2";
			var s2 = "z";
			var b = false;
			var o = {
				valueOf: function() {
					return -1;
				}
			}
			s1++;  //值变成数值3
			s2++;  //值变成NaN
			b++;   //值变成数值1
			o++;   //值变成数值0
			
	2,  一元加和减操作符
		一元加以一个加号( + )表示，放在数值前面，对数值不会产生任何影响
		var num = 25;
		num = +num;  //仍然是25
		
		不过在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值执行转换。
		布尔值false和true将被转换成0和1，字符串值会被按照一组特殊的规则进行解析
		对象是先调用它们的valueOf()和(或)toString()方法，再转换得到的值
		var s1 = "01";
		var s2 = "1.1";
		var s3 = "z";
		var b = false;
		var f = 1.1;
		var o = {
			valueOf: function(){
				return -1;
			}
		}
		
		s1 = +s1;  //值变成数值1
		s2 = +s2;  //值变成数值1.1
		s3 = +s3;  //值变成NaN
		b = +b;    //值变成数值0
		f = +f;    //值未变，仍然是1.1
		o = +o;    //值变成数值-1
		
		一元减操作符主要用于表示负数，例如将1转换成-1。当它用于非数值时，遵循与一元加相同的规则，只是最后将得到的数值转成负数
		
		这两个操作符主要用于基本的算术运算，也可用于转换数据类型
		 
	3，布尔操作符
		1，逻辑非
		逻辑非操作符由一个叹号(!)表示，可以应用于ECMAScript中的任何值。无论这个值是什么类型，这个操作符都会返回一个布尔值。
		逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反
		 
		可以同时使用两个逻辑非操作符，可以达到使用Boolean()函数的效果
		alert(!!"blue"); //true
		alert(!!0); //false
		
		2，逻辑与
		逻辑与操作符由两个 && 表示，有两个操作数
		只有在两边都为真的情况下，结果才为真
		有一个为假，结果就是假
		
		逻辑与可以应用于任何类型的操作数，而不仅仅是布尔值。在有一个操作数不是布尔值的情况下逻辑与操作就不一定返回布尔值。
		此时遵循下列规则：
			如果第一个操作数是对象，则返回第二个操作数
			如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象
			如果两个操作数都是对象，则返回第二个操作数
			如果第一个操作数是null，则返回null
			如果第一个操作数是NaN，则返回NaN
			如果第一个操作数是undefined，则返回undefined
			
		逻辑与属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值	
		
		也就是说，如果第一个值为true，那么返回第二个值
				  如果第一个值为false，那么直接返回第一个值
				  
		有一点需要注意：
						var a = true;
						var res = a && someVari;
						此时会报错，因为someVari未定义。这说明不能再逻辑与操作中使用未定义的值
			
		3，逻辑或
			由两个竖线符号 || 表示
			有一个为真，其结果就为真
			都为假的时候，结果才为假
			
			如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值。规则如下：
				如果第一个操作数是对象，则返回第一个操作数
				如果第一个操作数的求值结果为false，则返回第二个操作数
				如果两个操作数都是对象，则返回第一个操作数
				如果两个操作数都是null，则返回null
				如果两个操作数都是NaN，则返回NaN
				如果两个操作数都是undefined，则返回undefined
				
			逻辑或也是短路操作，也不能使用未定义的值
			如果第一个值是false，则取第二个值
			如果第一个值是true，则取第一个值
			
			var res = 100 || "aa"   //两边都不是布尔值，返回100
			
			
	4，乘性操作符
		ECMAScript定义了3个乘性操作符：乘法、除法和求模。在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算
		的某个操作数不是数值，后台会先使用Number()转型函数将其转换为数值。也就是说，空字符串将被当作0，布尔值true将被当作1
		1，乘法操作符由一个星号 * 表示。规则如下：
			如果操作数都是数值，则按照数学规则正常计算。超出表示范围，则返回Infinity或-Infinity
			如果有一个操作数是NaN，则结果是NaN
			如果是Infinity与0相乘，则结果是NaN
			如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号
			如果是Infinity与Infinity相乘，则结果是Infinity
			如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面规则
		
		2，除法操作符由一个斜线符号 / 表示。规则如下：
			如果操作数都是数值，常规计算。超出范围返回Infinity或-Infinity
			如果有一个操作数是NaN，则结果是NaN
			如果是Infinity被Infinity除，则结果是NaN   
			如果是零被零除，则结果是NaN
			如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号  -100/0 = -Infinity
			如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号 Infinity/10 = Infinity
			如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面规则
			
			A被B除  A/B   A是被除数  B是除数
			
		3，求模(余数)操作符由一个百分号 % 表示。规则如下
			如果操作数都是数值，常规计算，返回余数
			如果被除数是无穷大值而除数是有限大的数值，则结果是NaN   Infinity % 100 == NaN
			如果被除数是有限大的数值而除数是零，则结果是NaN   100 % 0 == NaN
			如果是Infinity被Infinity除，则结果是NaN
			如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数   100 % Infinity == 100
			如果被除数是零，则结果是零   0 % Infinity == 0
			如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面规则
			
	5，加性操作符有加法和减法两个操作符
		1，加法 + 。规则如下：
			如果有一个操作数是NaN，则结果是NaN
			如果是Infinity加Infinity，则结果是Infinity
			如果是-Infinity加-Infinity，则结果是-Infinity
			如果是Infinity加-Infinity，则结果是NaN
			如果是+0加+0,则结果是+0
			如果是-0加-0，则结果是-0
			如果是+0加-0，则结果是+0
		不过，如果有一个操作数是字符串，那么就要应用如下规则；
			如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来
			如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接起来
		
			
			
			
			
			
			
		 
	