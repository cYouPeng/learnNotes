一百零七，操作内联样式
	/*
	 *	通过js修改元素的样式
		语法：元素.style.样式名 = 样式值
		注意：如果css样式名中含有 - 这种名称，在js中是不合法的
			比如background-color，需要将这种样式名修改为驼峰命名法。去掉-，将-后的字母大写
				div.style.width = "120px";
				div.style.backgroundColor = "blue";
				div.style.borderTopWidth = "10px";
		我们通过style属性设置的样式都是内联样式，而内联样式有较高的优先级，所以通过js修改的样式往往会立即显示
		但是如果在样式中写了!important，则此时样式会有最高的优先级
			即使通过js也不能覆盖该样式，此时会导致js修改样式失效。所以尽量不要为样式添加!important
			
		/*
		 *	通过js读取元素的样式
			语法：元素.style.样式名
			通过style属性设置和读取的都是内联样式，是无法读取样式表中的样式的
			
一百零八，获取元素的样式
	/*
	 *	获取元素当前显示的样式
	 *	语法：元素.currentStyle.样式名
			它可以用来读取当前元素正在显示的样式
			如果当前元素没有设置样式，则获取到的是默认值
		currentStyle只有IE浏览器支持，其它浏览器都不支持
			alert(div.currentStyle.backgroundColor); //yellow
			alert(div.currentStyle.width); //auto  没有设置width的情况下返回其默认值auto
			
	/*
	 *	在其它浏览器中可以使用 getComputedStyle() 这个方法来获取元素当前的样式
			这个方法是window的方法，可以直接使用
		需要两个参数：
			第一个，要获取样式的元素
			第二个，可以传递一个伪元素，一般都传null
		该方法会返回一个对象，对象中封装了当前元素对应的样式
			可以通过 对象.样式名 来读取样式
			如果获取的样式没有设置，则会获取到真实的值，而不是默认值
				比如：没有设置width，它不会获取到auto，而是一个长度值
		但是该方法不支持IE8及以下的浏览器												
		通过currentStyle和getComputedStyle()读取到的样式都是只读的，不能修改。如果要修改必须通过style属性
				alert(getComputedStyle(div, null).backgroundColor); //rgb(0,0,0) 会返回一个rgb值
				alert(getComputedStyle(div, null).width); //1200  没有设置width情况下
					
			
			
			
			
			
一百零九，自定义的getStyle()
	/*
	 *	参数：
			obj 要获取样式的元素
			name 要获取的样式名
		function getStyle(obj, name){
			if(window.getComputedStyle){    //此处必须要加window
				//谷歌、火狐等浏览器的方式
				return getComputedStyle(div, null)[name];
			}else{
				//IE8及以下的方式
				return div.currentStyle[name];
			}
		}
		或
		if(obj.currentStyle){   //这种方式对于IE9来说是优先使用currentStyle，最好还是优先使用getComputedStyle，所以不推荐
		
		}else{
		
		}
		或 
		return window.getComputedStyle ? getComputedStyle(div, null)[name] : div.currentStyle[name];
		
一百一，其它样式相关的属性
	/*
	 *	clientWidth
		clientHeight
			-这两个属性可以获取元素的可见宽度和高度
			-这些属性都是不带px的，返回的都是一个数字，可以直接进行计算
			-会获取元素高度和宽度，包括内容区和内边距，不包括边框
			-这些属性都是只读的，不能修改
				alert(div.clientWidth); //120
				
	/*
	 *	offsetWidth
		offsetHeight
			-获取元素整个的宽度和高度，包括内容区、内边距和边框
			-就是多了一个边框，其它和上边没有区别
				alert(div.offsetWidth); //140
				
	/*
	 *	offsetParent
			-可以用来获取当前元素的定位父元素
			-会获取到离当前元素最近的开启了定位的祖先元素
				如果所有的祖先元素都没有开启定位，则返回body
					var op = div.offsetParent;
					alert(op.id);
					
	/*
	 *	offsetLeft			
		offsetTop
			-当前元素相对于其定位父元素的水平/垂直偏移量
				alert(div.offsetLeft); //120
				
	/*
	 *	scrollWidth
		scrollHeight
			-可以获取元素整个滚动区域的宽度/高度
				假设div4的width为300px，它的子元素div5的width为600px，div4设置overflow:scrollHeight
					那么此时div4的scrollWidth为600px，高度亦如此
					
	/*
	 *	scrollLeft
		scrollTop
			-可以获取水平/垂直滚动条滚动的距离
				//因为div5溢出其父元素，导致父元素出现滚动条，所以滚动条应该是相对于div4的
				alert(div4.scrollLeft); 
		
		//当满足 scrollHeight - scrollTop == clientHeight 
		//说明垂直滚动条滚动到底了   宽度亦如此
		
		
	<p id="info">协议...</p>
	<input type="checkBox" disabled="disabled" />我已仔细阅读协议
	<input type="button" value="注册" disabled="disabled" />
	
	#info{
		width: 300px;
		height: 500px;
		background-color: #bfa;
		overflow: auto;
	}
	
	<script>
		window.onload = function(){
			/*
			 *	当垂直滚动条滚动到底时表单项可用
			 *	onscroll
			 *		-该事件会在元素的滚动条滚动时触发
			 */
			 
			//获取id为info的p元素
			var info = document.getElementById("info");
			//获取两个表单项
			var inputs = document.getElementsByTagName("input");
			
			//为info绑定一个滚动条滚动的事件
			info.onscroll = function(){
				//检查垂直滚动条是否滚动到底
				if(info.scrollHeight - info.scrollTop == info.clientHeight){
					/*
					 *	滚动条滚动到底，使表单项可用
					 *	disabled属性可以设置一个元素是否禁用
					 *		如果设置为true，则元素禁用
					 *		如果设置为false，则元素可用
					 */
					inputs[0].disabled = false;
					inputs[1].disabled = false;
				}
			}
		}
	</script>
	

一百一十一，事件对象
	<div id="areaDiv"></div>
	<div id="showMsg"></div>
	
	<script>
		/*
		 *	当鼠标在areaDiv中移动时，在showMsg中显示鼠标的坐标
		 *	onmousemove
		 *		-鼠标在元素中移动时会触发该事件
		 */
		//获取两个div
		var areaDiv = document.getElementById("areaDiv");
		var showMsg = document.getElementById("showMsg");
		areaDiv.onmousemove = function(event){
			/*
			 *	事件对象
					-当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数
						在事件对象中封装了当前事件相关的一切信息
						比如：鼠标的坐标、键盘按键被按下、鼠标滚轮滚动...
					但是在IE8中，响应函数被触发时，浏览器不会传递事件对象
						在IE8及以下的浏览器中，是将事件对象作为window对象的属性保存的
							window.event 兼容IE和谷歌 不兼容火狐
							event 兼容谷歌和火狐 不兼容IE8
							
			//解决事件对象的兼容性问题
			//if(!event){
				//event = window.event;
			//}
			//或
			event = event || window.event;
			
			/*
			 *	clientX 
			 *	clientY
			 *		-可以获取鼠标指针的水平/垂直坐标
			 */		
			var x = event.clientX;
			var y = event.clientY;
			showMsg.innerHTML = "x: "+x+"      y: "+y;						 
		}
	</script>
	
一百一十二，div跟随鼠标移动
	<div id="box4"></div>
	
	#box4{
		width: 100px;
		height: 100px;
		background-color: red;
		position: absolute;  /* 如果不写position的话，那么js中设置left和top都是无效的 */
	}
	
	<script>
		window.onload = function(){
			var box4 = document.getElementById("box4");
			//绑定鼠标移动事件
			document.onmousemove = function(event){
				//解决事件对象的兼容性问题
				event = event || window.event;
				//获取鼠标的坐标
				var left = event.clientX;
				var top = event.clientY;
				//设置div的偏移量
				box4.style.left = left + "px";
				box4.style.top = top + "px";
			}
		}
		/*
		 *	此时执行代码看起来一切正常，但是当我把box4的body的高度改为1000px时，会出现鼠标与div分离的情况
		 *
		 *	clientX和clientY
				用于获取鼠标在当前的可见窗口的坐标
			而div的偏移量是相对于整个页面的

			
	</script>
			
		
				
	
			