14，ES6 promise对象原理详解
	1，理解：
		Promise对象：代表了未来某个将要发生的事件(通常是一个异步操作)
		有了promise对象，可以将异步操作以同步的流程表达出来，避免了层层嵌套的回调函数(俗称'回调地狱')
		ES6的Promise是一个构造函数，用来生成Promise实例
	2，使用promise基本步骤(2步)：
		创建promise对象
		let promise = new Promise((resolve, reject) => {
			//初始化promise状态为pending
			//执行异步操作
			if(异步操作成功){
				resolve(value); //修改promise状态为fullfilled
			}else{
				reject(errMsg); //修改promise状态为rejected
			}
		})
	3，promise对象的3个状态
		pending: 初始化状态
		fullfilled: 成功状态
		rejected: 失败状态
	4，应用：
		使用promise实现超时处理
		
		使用promise封装处理ajax请求
		let request = new XMLHttpRequest()
		request.onreadystatechange = function(){
			
		}
		request.responseType = 'json';
		request.open('GET', url);
		request.send();
		
		
	//创建promise对象
	let promise = new Promise((resolve, reject) => { //该函数为同步执行
		//初始化promise状态：pending：初始化状态
		console.log(111)    
		//执行异步操作，通常是发送ajax请求，开启定时器
		setTimeout(() => {
			console.log(333)
			//根据异步任务的返回结果去修改promise的状态
			//异步任务执行成功
			//resolve('哈哈'); //修改promise的状态为 fullfilled：成功的状态
			
			//异步任务执行失败
			reject(555); //修改promise的状态为 rejected: 失败的状态
		}, 2000)
	})
	console.log(222)
	
	//promise
		//.then(() => {  //成功的回调
			//console.log('成功了...')
		//}, () => {
			//console.log('失败了...')
		//})
		
	promise
		.then((data) => {  //成功的回调
			console.log(data, '成功了...')    //可以传参，也可以不传。可以写形参，也可以不写
		}, (error) => {
			console.log(error, '失败了...')
		})
		
	
15，ES6 promise对象案例练习	
	//定义获取新闻的功能函数
	function getNews(url){
		let promise = new Promise((resolve, reject) => {
			//状态：初始化
			//执行异步任务
			//创建xmlHttp实例对象
			let xmlHttp = new XMLHttpRequest();
			//绑定监听 readyState
			xmlHttp.onreadystatechange = function(){   state从0变化到5，该函数被执行4次，第一次从0到1，函数执行if条件不满足
				执行else，promise状态为rejected，执行失败回调，所以这样的逻辑是不对的
				//if(xmlHttp.readyState === 4 && xmlHttp.status == 200){   //请求成功
					//console.log(xmlHttp.responseText)
					//修改状态
					//resolve(xmlHttp.responseText) //修改promise的状态为成功
				//}else {  //请求失败
					//reject('暂时没有新闻内容')
				//}
				
				if(xmlHttp.readyState === 4){   
					if(xmlHttp.status == 200){  //请求成功
						//console.log(xmlHttp.responseText)
						//修改状态
						resolve(xmlHttp.responseText) //修改promise的状态为成功
					}else {  //请求失败
						reject('暂时没有新闻内容')
					}					
				}
				
			}
			//open 设置请求的方式以及url
			xmlHttp.open('GET', url)
			//发送
			xmlHttp.send();
		})
		return promise;
	}
	
	getNews('http://localhost:3000/news?id=2')
		.then((data) => {
			console.log(data)  //typeof data 为string，因为后端返回数据就是json字符串，至于为什么有的网络插件返回的数据
							   //为js对象，是因为这个插件替你进行了转换，此处我们得手动转换一下
			//发送请求获取评论内容 准备url
			let commentsUrl = JSON.parse(data).commentsUrl;
			let url = 'http://localhost:3000' + commentsUrl;
			//发送请求
			return getNews(url)
		}, (error) => {
			console.log(error)
		})
		.then((data) => {
			console.log(data)
		}, () => {
		
		})