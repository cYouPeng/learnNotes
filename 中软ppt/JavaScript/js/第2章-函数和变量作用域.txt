参数不写var

函数调用： 1,在<script>中直接写函数名
	  2,写在a标签中  <a href="javascript:
	  3,在事件中
传参可以和函数中形参不匹配，传的实参个数可以多于形参个数，也可以少于，没被赋值的形参为underfined

定义2个同名函数，后者覆盖前者
args - arguments的缩写  arguments[0]容易产生越界

		<script type="text/javascript">
			function abs(num){
				
				if(!isNaN(num)){
					//num = parseFloat(num);
					if(num>0){
						return num;
					}else{
						return -num;
					}
				}
			}
			document.write(abs("hello"));
			document.write(abs(-100));
			document.write(abs("-123"));
		</script>   

ES5新增严格模式  "use strict"
传underfined相当于未传参，，某一个参数没传参或使用underfined的情况下，就会使用默认值

严格模式下，对变量再次赋值，不会影响arguments数组中元素的值
非严格模式下，对变量再次赋值，会影响arguments数组中元素的值

只要使用参数默认值，即使没写use strict，也会应用严格模式，改变形参，arguments里元素值不会跟着改变

ES5的严格模式，，ES6的参数默认值

不具名参数只能放在参数列表最后
刨去前面的具名参数，后边剩下的都传给不具名参数（严格来说，它是类数组对象，用起来跟数组差不多，又不是真正的数组）

arguments后面的部份就是不具名参数/不确定参数，，前面没具名参数，则和arguments一样
不具名参数的目的在于替代arguments

函数可作为参数进行传参或作为返回值

函数表达式必须先定义后调用，普通函数可以先调用后定义

java/js中if后若只有一条语句，大括号可以省略

函数回调：调用一个函数，这个函数的一个或多个参数需要我们提供函数，匿名函数传过去了，在那边又被调用

参数函数一定要写默认值
对underfined进行调用会出错

匿名函数三件事：赋值一个变量/传参/返回值
		<script type="text/javascript">
			function outer(){
				function inner(){
					//inner就是一个块级函数,这种函数声明的嵌套被js语法禁止，但是大多数浏览器支持，所以这不是一个好的方式
					alert('inner')
				}
				var iner = function(){
					//这是函数表达式，并非块级函数，在需要嵌套时，优先使用这种方式
					alert('in')
				}
				inner();
				iner();
			}
			outer();
		</script>                                                                                                                                          
(function(num){
   alert(num);
})(10); （参数列表，如果没参数，就空着）         这个叫立刻执行函数，  

回调函数三个条件：1，指针，指向一个函数(这个函数被调用，并且作为参数)                                            2，被调用，通过这个指针调用它所指向的函数
	         3，作为参数
		满足以上3点成为函数回调

箭头函数：参数 =>函数体   一个参数可以不写括号，没有参数或多个参数必须写
箭头函数的this是父元素的this

在非严格模式下，函数中定义变量，没写var，此时认为是全局的，是window对象的属性

函数也分全局和局部函数，，window的属性就是全局变量

switch case后面的代码量多的话，最好加个大括号，防止出错

函数中定义的变量，没有块级作用域，在整个函数中都可以用，离开所在块也无所谓

let定义的全局变量，不再是window对象的属性，
在同一作用域下，let不能重复声明变量，且必须在使用前进行声明
let 可以处理逻辑和语法的矛盾， let块级变量在块内的函数中可用