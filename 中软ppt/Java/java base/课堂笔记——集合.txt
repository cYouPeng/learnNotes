装箱：把值封装进对象
拆箱：把值从对象中取出

int a = 10;
a = a + 1; / a++;
手动装箱：Integer obj = new Integer(a);
手动拆箱：obj = new Integer(obj.intvalue()+1);

自动装箱：Integer num = 10; //省略了创建对象的代码，自动装箱
自动拆箱：num = num + 1 / num++  //省掉了对象.xxvalue()的过程

Object o = new Integer(29);
System.out.println(o);     输出29

Double num2 = 10; //错误
Double num2 = 10.0; //正确
Double num2 = (double)10; //正确
自动装箱的值一定要和包装类型相同，手动可自动转换

Integer sum = 0;
//for(int i=0;i<10;i++){
//	sum = sum + new Random().nextInt(50);//sum每次指向新的wrapper对象
//}
int tempSum = sum;
Random ran = new Random();
for(int i=0;i<10;i++){
	tempSum = tempSum + ran.nextInt(50);
}
sum = tempSum;
System.out.println(sum);

简单类型：基本类型+包装类型+String

枚举中构造器只能是私有的
枚举类调用values()方法，将枚举类中所有枚举值以数组的形式返回

成员内部类：可以访问外部类的所有(静态或实例)成员，不能定义任何静态成员，而静态内部类就没有此类限制
静态内部类：只能访问外部类的静态成员，而无论是发生在内部类的静态域或非静态域中

局部内部类：访问所在方法的局部变量默认为final，只能读，不能写
在方法中声明了局部内部类，那这个方法中所有的临时变量就都是final的
成员内部类和局部内部类一样，都可以访问外部类的所有成员(静态和实例)

new 接口名(){重写接口的方法}定义了一个接口的实现类，并创建这个类的对象
高内聚 低耦合
局部内部类：需要在方法内部反复调用这个类的对象

lambda:（参数）->表达式   或   （参数）->语句块

函数式接口：只有一个抽象方法的接口，或其他方法是默认实现
只有函数式接口才能用lambda
lambda不会被变成字节码文件
lambda只需实现方法覆盖，实现类，创建对象这些操作jdk会自动实现
接口也可以定义在类体里

线性表  --  元素紧密排列
|---|   优：查找效率高
|---|   缺：a,长度固定
|---|       b,增，删效率低
|---|
 java中用数组实现线性表
另外两种线性结构：栈和队列
栈：先进后出，后进先出  例：弹夹       存入元素：压栈         取出元素：弹栈
局部变量存在栈中，当作用域消失，弹栈  ， 在同一个栈中，不能有同名变量

队列：先进先出，后进后出   例：排队


链性表：空间不连续

开始-->A-->B-->C-->结束    A或B或C叫做节点，为有效节点，每个节点由两部分组成，数据和引用。数据就是存在这个节点中的值，而引用是指向下一个节点，也就是说，要想找到一个节点，只能通过它的上一个节点的引用。
    由于记事本中无法表达，每个节点在内存中的分配都是无序分配的，
节点：1，存储数据 2，下一节点的位置。。。不知道存什么，一般定义为Object



linkedList  一个一个节点相连   更接近一个纯正链表   双向链表
遍历查找  效率低
增删      效率高

ArrayList  和数组差不多  一个一个数组相连    可变长度数组
遍历查找  效率高
增删      效率低

ArrayList和linkedList不是同步的，非线程安全
Vector是同步的，但一般不用它，即使在有大量高并发需求时，我们也通常使用ArrayList来自定义个什么鬼

哈希表
名   值    名是唯一的    哈希表内部有算法，只要给名就可快速算出其对应的值
JDK中用Map实现哈希表，Map无父接口
Map接口常用方法：int size(),void clear(),boolean isEmpty(),V get(Object key) 取值
V put(K key,V value) 放值

Map没有索引值，我们是不讨论里边元素的顺序的
Map中要想修改key所对应的值，用put放一个相同的key和不同的value，此时这个key会替换前一个key
任何类型的值都可以是key，前提是保证它唯一



其实Map并不是一个纯正的哈希表，还融合了一些其它的东西，因为纯正的东西往往优点和缺点都很明显

往集合中传值的时候进行向上造型
从集合中取值的时候进行向下造型

Set keySet = map.keySet();//将集合中所有key组装到Set集合中，并返回这个Set集合

Map内部有对key独特的排序算法，并不根据先后插入元素的顺序

集合中不能存放基本类型的值，存数值实际是进行了自动装箱

实现Map接口的三个常用类：HashMap    Hashtable  LinkedHashMap
HashMap允许使用null键 null值  不是同步的
Hashtable 不允许使用null键和null值  是同步的
LinkedHashMap  输出元素的顺序和插入元素时的顺序是一样的

Set要求集合内所有元素不能重复，依据这个特性适合用来存放key

   Map的遍历：
	        Set keySet = map.keySet();//将map中所有的key组装到set集合中，并返回这个set集合
		//low的遍历set的方案
//		Object[] keys = keySet.toArray();//将set转存成一个数组
//		for(Object key: keys){
//			Student s = (Student)map.get(key);
//			System.out.println(s);
//		}
		//优选的方案
		Iterator iterator = keySet.iterator();
		while(iterator.hasNext()){
			Object key = iterator.next();//取出迭代器所指向的下一个元素，迭代器指向下个
			String s = (String)map.get(key);
			System.out.println(s);
		}
//		
//		Object key = iterator.next();//取出迭代器所指向的下一个元素，迭代器指向下个
	}
Map<String,String> map = new HashMap();
map.put("1","hello");
...
Set<String> keySet = map.keySet();
Iterator<String> ite = keySet.Iterator();
while(ite.hasNext()){
	System.out.println(map.get(ite.next()));
}
for(String key : keySet){
	System.out.println(map.get(key));
}


 接口实现泛型两种方式：
一种是实现接口时指定泛型
一种创建对象时指定泛型具体类型
加了泛型之后，就可以用加强for循环进行遍历了