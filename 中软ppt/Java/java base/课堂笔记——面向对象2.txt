Object是所有类的超类
自定义的类只是省略了extends Object

构建子类对象的过程中，会先调用父类的构造方法(帮助子类对象完成创建的
过程)
为什么要调用父类的构造方法？因为子类不知道父类有哪些属性，这时就可以由父类构造器在子类对象的内存中开辟一块空间用来存放从父类继承来的属性和方法在方法区的引用，父类构造器都调用结束之后，再调用当前类的构造器
                   堆
new Dog()        |Object
    Animal()     |
    Object()     |Animal
                 |
                 |Dog

在子类对象内存中，父类构造器来划分空间
一个类的构造器只能知道自己类有哪些属性和方法
最先执行的一定是Object

先调用父类构造器，只是帮助子类对象在内存中分配空间来存放从父类继承来的属性等，并没有创建父类对象，只是帮助子类更好地去创建对象

在构造方法中，this和super不能共存，因为它俩都要求是第一条语句
override 重写

直接输出对象，实际是对象.toString()(Object里的方法)
System.out.println(obj.toString);
StringBuffer中重写了toString方法

@override(注解)强制要求下边方法为重写父类中的方法，在编译期间进行语法检查是否为重写方法

重写父类方法，方法名，参数列表都相同，但是权限不符合规则，此时就不是新建了一个方法，编译器会报错的

实例初始化块写在哪个类里，调用这个类的构造器时，就会先执行类里的实例初始化块

super去调用从父类继承下来的，没有被覆盖的，重写之前的
this是覆盖之后的
如果方法没有重写，它俩调用的方法是一样的，
子类重写父类中方法，用this去访问是重写之后的方法；要想访问重写之前的，只能用super

属性不存在覆盖，子类和父类中同名属性，是两个不同的属性
子类和父类中有同名的属性，各自方法访问各自的属性，子类方法操作子类当中的属性；父类方法操作父类当中的属性


a.b()从原理上，计算机执行角度讲，是a发送了一个叫b的消息给jvm，由jvm完成调用的过程

多态：当一个对象调用方法的时候，因为对象类型的不同，而产生不同的行为

编写代码时，不确定是哪个类的对象调用的这个方法

只要构造器被调用，就会执行初始化块
在子类构造器中，使用super显式调用父类构造器，就不会隐式调用父类无参构造器了

构建子类对象，并且子类中实例初始化块，它会先去执行父类构造器，然后执行子类实例初始化块，再然后子类构造器

静态绑定：类里有没有这个方法，和编译时类绑定
动态绑定：这个方法具体和哪个类绑定
运行期的动态重新定向
重写，static也得一致

1，语法概念
2，经典代码    冒泡排序 单例模式
3，重要API     String sb  的方法等

抽象类和普通类最重要的区别：不能被创建对象
抽象类可以去继承普通的类
set和get方法要放在普通方法后面

this只有属性和局部变量同名时，为加以区分时不能省略，其它时候都可省略

因为实现了运行期的动态绑定，所以实现了多态

引用类型的常量不能改变引用关系，但是内部的属性或元素可以改变
基本类型的常量不能第二次赋值

属性是final，在初始化块或构造器或在属性定义的位置为其赋初值
该属性不能拥有setter

1<<0  1 ; 1<<1 2 ; 1<<2  4 ;1<<3  8

abstract和fianl不能共存

接口里只能有属性和方法，但属性并不是用来描述类的特征的
属性必须是public static final的
方法必须是public abstract
但一般很少在接口里同时定义属性和方法

接口和抽象类都不能被创建对象
属性前public static final可省略    int  VALUE = 0;
方法前 public abstract  可省略  void method();   不可以写方法体

继承父类(extends 父类名)要写在实现接口(implements 接口列表，多个接口用逗号间隔)前

一个子接口可以继承多个父接口

