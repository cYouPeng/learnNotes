控制台不能输入char

父类引用指向子类对象，只能调用子类中重写的方法，不能调用子类本身的方法

Random ran = new Random();  ran.nextInt(10);

类的使用：1，完成对类的定义 2，创建类的对象  3，访问和操作它的属性和方法

成员变量和数组元素有默认值  局部变量没有默认值

栈 -->引用  ；  堆-->实例    
没有引用，以后找不到实例 ； 没有实例，引用无意义
Student s = new Student();   =代表把堆内存中的首地址赋给引用    
栈区有顺序，堆区没有顺序

参数传递
基本类型  传的是值的拷贝  对实参没有影响
引用类型  传的是引用地址  最终二者指向同一块内存           它俩都是值传递，都是拷贝/副本

方法有访问属性的权力，但不能把属性当成方法的参数


源文件中所有类必须是同一包下，main方法一定要放在公有类中
成员有属性和方法

静态方法只能访问静态成员，若想在静态方法里访问非静态成员，可以创建对象去调用

this只有在实例方法中才会存在，为什么可以在实例方法中直接调用本类的属性和方法，因为它省略了this

this代表当前对象，调用这个方法的对象   this可以省略(如果写上this,后面会有联想提示)

静态域({ }括起来的空间，包括但不限于方法)没有this,这时被省略的可以认为是类名

为什么静态域中不能有this？因为静态成员可以通过类名调用，或多个对象，如果有this，就不确定this代表哪个

静态方法只能访问静态成员  ， 非静态方法可以访问静态成员和非静态成员

变量分类：1，根据数据类型来分：基本类型和引用类型
	  2，根据作用域来分：属性和局部变量
1和2它俩之间是没有任何关系的，就像一个人可以根据性别来分男女，也可以根据年龄来分成年人和未成年人，男和成年人它俩是没有关系的

属性和局部变量的区别只看声明位置

非静态属性 --> 非静态成员变量 --> 实例属性 --> 对象属性
静态属性 --> 静态成员变量

堆区的不能直接访问，new出来的对象没有名字

方法调用结束其内部的局部变量会跟着方法对应的栈区一起被回收。但此时里面new出来的对象仍在堆内存在，只不过没有引用
指向它就不能再使用了，

栈中 保存方法的局部变量   可以有基本类型或引用类型   它是先进后出的  就像弹夹
堆区 保存new出来的对象 和对象的属性值(可以是基本或引用)
方法区：方法不管调不调用都会存在方法区里，而栈中则是当方法调用时才会开辟空间

	
属性 - field   方法-method  构造器--constructor

构造器里的this表示正在创建的对象，不表示调用方法的对象
当类中没有任何构造方法时，java会提供一个默认构造方法(没有参数，权限为public)

构造器可以用在四种地方：new this() super() 反射
可以在构造器里调用本类实例方法 this.method()  也可省略this
构造器也是非静态域
用new调用构造器的时候是先创建对象，再去执行构造器里的代码块

创建对象或用类名.静态成员都可以认为是对这个类的使用。当一个类第一次被使用的时候，会在使用前去加载这个类。
当类被加载时，会执行静态初始化块(只执行一次)。静态初始化块的用途：给静态属性赋初值
在每次创建对象的时候在构造器中的代码执行之前执行实例初始化块
实例初始化块的用途：所有构造器都需要执行的代码，就可以把这段代码放到实例初始化块中
实例初始化块和构造器的区别：1，构造器有分配空间的功能 它没有  2，构造器可以有参数，它不可以
实例初始化块里可以有this
对象创建之后 -->执行实例初始化块-->构造器里的代码


overload 重载
满足条件：1，同一个类中
	  2，方法名相同且参数列表不同     只要满足这两个条件就构成重载   和修饰符和返回值类型是没有任何关系的

如果方法名和参数列表一样，那就是重复定义

重载只看方法名和参数列表

调用时候，如果没有直接匹配，会去找最接近的那个方法

在代码中调用方法，在编译期间就确定了应该调用哪个方法，如果没有所匹配的方法，会报错

public void setName(String name){
		name = name;         按照就近原则，前边的name指的是形参，后边的是属性
	}

 private 类的内部可以访问，不要说本类可访问，因为还有内部类的存在

protected 不同包的子类也可访问，但只能通过super去访问，不能通过创建对象去访问，

构造器也有访问权限

单例模式：一个类只能创建一个唯一的对象 
懒汉模式：什么时候需要什么时候用   线程不安全
饿汉模式：一开始就创建好，生命周期长


对象是一个统一的称呼，模糊的，实例只是堆中的一块内存

构造器定义为私有的，这样就可以阻止在其它类中创建本类的对象


变量根据位置来分：属性和局部变量    根据数据类型来分：基本和引用

             |                                         class A{
             |					          String s;   -->属性、引用类型变量
属性         |						  int num;    -->属性、基本类型变量
             |					          public A(){
----------------------------------			     s = "hello";   -->引用类型的值,"hello"是一个对象
             |						     num = 10;   -->基本类型的值
局部变量     |						  }
             |					          public void method(){
             | 						     int a = 10;     -->局部变量、基本类型变量
							     Scanner input = new Scanner(System.in);   -->局部变量、引用类型变量
 基本类型          引用类型
（基本类型值）     （引用类型的值叫做：对象或实例）
	 
一个子类只能继承于一个父类，但一个父类可以有多个子类

子类事物去替换父类事物，叫向上造型

如果父类中的属性是private，子类是有这个属性的，只是没有权限去访问它

java只有访问权限，没有继承权限(C++有)

任何一个类的成员不会因为继承而改变它的权限
父类中是什么权限，子类继承下来，依旧是什么权限
子类能够继承父类的只有属性和方法	



