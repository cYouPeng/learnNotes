通过实现Runnable接口创建线程，
如果多个线程对象的target都是同一个Runnable实现类的实例，那么这多个线程共享实现类里的成员变量
如果多个线程对象的target不同，那么每个线程有各自的实例变量，只共享静态变量

对于两个(或多个)线程而言，当系统给线程一分配的时间段用完之后，不管线程一有没有执行完它的线程执行体，都会被强制中断
，目的是使其它线程获得执行的机会，此时可能是线程二获得时间片段，当线程二的时间片段用完以后，跟线程一一样的结局。此时线程一可能再次执行，注意，这时会继续执行它上一次执行体里没执行完的代码，而不是重新执行线程执行体。。什么时候算是这个线程结束了呢，也就是死亡 ---》 当执行体中的代码在一次次的时间片段终于执行完了的时候



"当一个线程开始运行后，它不可能一直处于运行状态(除非它的线程执行体足够短，瞬间就执行结束了)" -- >
“不可能一直处于运行状态” 不考虑阻塞的情况下，这个线程可能在一个时间片段内执行不完，这样呢当这个时间片段用完了，系统会剥夺该线程所占用的资源。这样这个线程就变成了就绪状态

但是有一个疑惑：public class SecondThread implements Runnable{
			private int i=2;
			public void run(){
				++i;
				System.out.println(Thread.currentThread().getName()+" "+i);
			}	
			public static void main(String[] args) {
				// TODO Auto-generated method stub
				SecondThread st = new SecondThread();
				Thread t1 = new Thread(st,"明月多情应笑我，笑我如今");
				Thread t2 = new Thread(st,"辜负春心，独自前行独自吟");
				t1.start();
				t2.start();
			}

		}
当一个线程的时间片段用完了，即使线程执行体中是一个循环，那么也会发生这个循环中断的情况，等待下一下系统分配资源，接着上一次循环的地方接着执行，只要时间片段用完了，甭管你执行体执行到哪里，都会中断


进程是执行的一种状态，同一进程的线程之间共享内存，不同进程互相独立
jack线程的生命周期：新建状态，就绪状态，运行状态，阻塞状态，死亡状态
只有运行状态需要cpu
run()不能显示调用，即使调用，也不会启动线程

在线程中出了一个异常，主线程中断，余下线程也不会执行，只会执行完当前线程

结束线程并不会立刻结束，会有一阵缓冲，阻塞状态

setDaemon(true) 用户线程，守护线程

实现线程通讯的代码必须写在同步块中       uri统一资源标识符
synchronized(参数){   参数必须是同步的

}
class Single{
	private static volatile Single instance;
	private Single(){
		
	}
	public static Single getInstance(){
		synchronized{
			if(instance == null){
				instance = new Single();
			}
		}
		return instance;
	}

}