ref:引入另一个bean节点，让这个对象成为该属性的值
value：直接给属性一个确定的值

设置注入：通过这个属性的set方法注入
构造注入：利用构造器实现属性注入

spring依赖注入是通过设置注入来实现的，构造注入不常用

@Autowired 适合属性已经确定的情况

不是由自己创建对象，而是由spring注入

IOC和DI的关系：
IOC:反转控制 IOC体现一种思想，我需要的东西不由我来创建，由别人来提供
DI:依赖注入 是实现上述思想的方式/技术       spring通过ID来实现IOC
DI两种手段：1，设置注入(set) 2，构造注入

execution(返回值类型 空格 包 类 方法(参数))

环绕通知可以知道方法执行时间

方面代码一定是公共代码

切面没办法获得web资源，request啥的获取不了     切面比过滤器更公众

classpath = WEB/classes      发布路径在classes里应把文件放在src下

maxActive 最大活跃时间   maxWait 最大等待时间

mybatis的dataSource在spring里配置，别名等还是在mybatis里配置

controller里的service属性应该是注入的，service里的mapper属性也应该是注入的，二者必须保持一致

在业务层去做事务管理

视图层 - controller 操作 servlet api 接收返回数据
业务层 - service 增删改查 事务 多个mapper的操作，可以保证在一个事务里

pageHelper第三方分页插件
今天讲一下分页使用第三方的pageHelper插件
使用方式：
1-加入jar包

2-mybatis配置文件中配置pagehelper插件的配置节点

<plugins>
    <plugin interceptor="com.github.pagehelper.PageHelper">
         <property name="dialect" value="mysql"/>
    </plugin>
dialect：数据方言，可以是mysql或oracle、sqlserver等
即使用哪种数据库，进而生成针对该数据的分页查询语句
在执行查询时，该插件拦截准别执行的sql语句，然后更改sql为分页的查询语句，继而实现分页查询，所以mapper中的sql不需要考虑分页
pageinfo包括2部分，查询的结果和总的条目数



	public PageInfo getEmps(Integer pn, Integer rn){
		PageHelper.startPage(pn, rn);//pn查询的页数，rn每页行数

		List<Emp> list = empMapper.selectAllEmps();
		PageInfo<Emp> p=new PageInfo<Emp>(list);//查询的结果加入pageInfo，总条目数不需要我们来处理
		return p;
	}

update写俩 一个改密码，一个改其他，根据实际业务来

controller获取http资源，操作http资源

controller service mapper 可能相互套用

不同controller方法/类能用到相同service方法，区别为需给mapper层注入不同参数，这也是为啥分成这三个

注解 特殊的文本标识