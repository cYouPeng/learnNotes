MVC  model 模型   V 视图  C controller 控制器(可使url和视图之间解绑，把绑定权交给控制器)

服务员  视图层：数据生成/接收(是否是有效数据)、不在视图层进行验证
传菜    业务逻辑层：进行if判断，登录用户数据由视图层处理
厨师    数据持久化层：提供持久化数据(可以从数据库、文本文件中获取不限)     三层结构

DispatcherServlet  前端控制器

侵入式  非自选麻辣烫
非侵入式 自选麻辣烫

重量级
轻量级

EJB 侵入式 重量级框架  EJB2.0

struct1 轻量级 非侵入式
struct2 轻量级 非侵入式  源于webpack2框架  基于拦截器，组件式框架 非耦合、它和struct1没有任何关系，只是名字相似而已

spring mvc spring有八大模块，其中之一为MVC，它有着和struct2差不多的功能，而由于MVC为spring内置，不需要进行整合，并且mvc对新技术支持很迅速

ssh/ss2h  spring struct2 herbatn
ssm pring spring mvc my batis

spring boot
spring cloud     它俩是面向微服务，微服务：把大的服务按照功能拆分成一个个小的模块       有横向拆 纵向拆
微服务一定涉及到sso单点登录

my batis 前身为Ibatis

ModelAndValue  model为跳转时携带的数据  view为跳转的目标

spring mvc的流程为必考

在mvc.xml中写得base-package也会扫描子包中的类  

aop:有它才能使用注解

返回String 加@ResponseBody    返回ModelAndView  不加@ResponseBody

HandleMapping只在第一次访问时扫描一遍handle，所以说你在controller里改方法tomcat会自动编译，但是添加方法的话，必须手动重启一下服务



基于配置
controller类必须实现Controller接口，重写方法
所有controller的配置是在mvc.xml中完成



如果@RequestMapping("/user")是修饰类的话，就相当于baseURL,起到拼接的作用


controller参数/返回值 这里说的是方法的参数/返回值

简单数据类型 只能处理请求参数和FormData，不能处理JSON  不要写int double,写成包装类型(因为如果是0的话，你确定是否是默认值)
请求参数和FormData没有区别

可以在value中写占位符     
restful风格：/user/lisi/pwd/123
提交时也得用这种风格

@RequestParam 只能处理Content-Type为application/x-www-...    其中value必写，它的值对应请求参数，然后再传给右侧的方法参数

如果请求参数为json，要加@RequestBody

数据越复杂，json更有优势，FormData限制越大

在servlet里处理json，需要自己手动拆分

controller参数4种: 简单/对象
		   占位符
		   @RequestParam 请求参数
		   @RequestBody json           其中最常用的有2种：对象和@RequestBody

controller返回类型为void须手动跳转(转发/重定向)
	  返回为Model 和void是一样的处理

view和String可直接返回view或字符串

4.2之后可以使用gson，，不跳转其它view，一定要加@ResponseBody

jackson 返回null   gson不返回null

在处理FormData时在mvc.xml中添加如下代码
<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver" >

<property name="maxUploadSize" value="500000" />

</bean>
并且还要添加两个有关文件上传的jar包
























