反射：在运行期确定类，实现动态编程,java的一种动态的开发方式，允许我们在程序运行阶段而非编译阶段来确定一个类的类型，进而对这个类进行创建对象，调用方法等操作
内省：基于反射机制，操作bean类已封装的属性

DOM和SAX的区别：
dom:全部解析文件进内存，优：可修改dom结构  缺：占内存
SAX:基于事件驱动，按需加载，优：内存小，消耗资源小  缺：不能修改

资源：存储，运行时间(时间复杂度，空间复杂度)

cookie和session：cookie:客户端用来存储信息的一种容器，对每一条信息可以设置失效时间，不指定下，关闭浏览器即失效；cookie可以在服务端被操作(访问，修改),服务端如何得到？浏览器发送请求时，会在请求头中携带cookie(服务端允许访问的cookie，客户端才能携带)服务端可以通过请求头得到cookie值，在响应头中有一个setCookie，可以把cookie返回给客户端，，从kookie角度讲，跟session一点关系都没有；客户端临时存储，设置失效时间；服务端可以对cookie进行操作，请求头cookie，响应头setcookie

session：服务端识别客户身份，会话跟踪机制，通过Httpsession类来实现，客户端第一次访问的时候，服务端发放一个令牌，之后客户端再次访问，会携带令牌，服务端根据令牌来识别客户身份，之后每一次访问，都提交这个令牌，我就可以根据这个令牌识别你的身份，，不要说登录，要说访问，，不是必须使用cookie，jsessionid，，令牌就是访问者的身份的标识，讲到这里，不要提cookie，跟它俩没关系，也可以使用其它容器来存储令牌，cookie只是一种默认的方式

javaee技术默认使用cookie来存储这个令牌，之后的每一次会通过请求头来存储这个令牌，通过服务端来写入这个令牌，这个令牌通常叫做jsessionid，cookie只是session默认的一种操作方式，cookie就是吃饭用的碗，当然，也可以用别的容器吃饭，在浏览器查不到jsessionid，隐藏起来了

服务端setCookie确定客户端可以浏览器进行连接的cookie，在客户端请求头中加上cookie

在响应头中添加允许跨域

RIA:更多的功能在客户端去实现
http:任何处理http请求的服务器

web应用服务器：处理应用程序的一些复杂请求，专门给web应用提供服务，不一定基于http协议

老师写的dog既是http又是web服务器

web应用开发两大阶段：1，jsp ：web application server返回一个完整的http页面
		    2，前后端分离: 异步，前端服务器返回相关的数据(该数据早期基于xml，现在基于json)

dao类相当于应用服务器

Tomcat属于apache联盟开发

TomCat访问量超过200，开始阻塞，前200是并发的
TomCat可以处理java，php
IIS支持.net，不支持java

web应用服务器又叫servlet容器

TomCat相当于dog包下的server类
httpServlet相当于servlet类

web应用程序:new -> dynamic web project 
	    new -> project -> web -> dynamic web project

TomCat添加的多个web程序中有一个是错误的，那整个TomCat都用不了

servlet jar包放到WebContent->WEB-INF->lib下，注意要仔细区分一下该jar包是几点零的
XML文件放在WEB-INF下，不是lib里  且web.xml不能改变名字
配置节点：<servlet-mapping>
		<servlet-name>addServlet</servlet-name>
		<url-pattern>/user/add</url-pattern>
	</servlet-mapping>
	<servlet>
		<servlet-name>addServlet</servlet-name>
		<servlet-class>servlet.AddServlet</servlet-class>
	</servlet>
url-pattern中不写服务名
在前端页面中url后写http://localhost:8080/myWeb(项目名)/hello(资源名)，注意这个项目名不要省略

tomcat的目录结构：
	backup:自动备份
	bin:命令  startup.bat 启动tomcat不一定非得要启动eclipse，
	          shutdown.bat 结束服务，或者直接关闭窗口也可以(杀猫)
	conf:configuration 配置 context.xml 去哪里找xml文件
				server.xml
				web.xml session-config 非活跃响应时间 默认30分钟
				tomcat-user.xml：管理员

	lib：装jar包 为公共lib
	logs:日志 什么时候启动，什么时候出错
	webapps和wtpwebapps一样的功能，存放添加过的web程序，具体放在哪个里边，要看版本，注意：有时程序名和该文件夹下程序名字不一样，会出错
该文件夹下只存放web-content里的文件，还有项目中的源文件编译后的class文件会被放到WEB-INF下的classes下

	wrok:与jsp相关
	temp:临时文件夹

servlet的生命周期(单实例，多线程)
实例化：创建对象，默认第一次实例化，之后再次访问不再创建，直接跳到服务
初始化：init()
服务：容器根据请求方式决定调用什么方法
销毁：关闭tomcat服务
		request.setCharacterEncoding("utf8");//设定请求报文的字符集   get提交在请求行中的数据这么设置是没用的，因为已经打成ascii码，只对请求行中汉字有效
		response.setCharacterEncoding("utf8");//设定响应报文的字符集
		
		String id = request.getParameter("loginId");//得到请求参数loginId的值（字符串）,注意参数的大小写
//		String [] values = request.getParameterValues("重复提交的请求参数名")
		String pwd = request.getParameter("loginPwd");
		System.out.println("loginid:"+id+"\tloginpwd:"+pwd);

		String origin = request.getHeader("Origin");
		response.addHeader("Access-Control-Allow-Origin", origin);//添加响应头
		response.addHeader("Content-Type", "application/json; charset=utf-8");
		response.addHeader("Allow", "GET,OPTIONS,POST");
		response.addHeader("Access-Control-Allow-Headers", "Content-Type,Access-Control-Allow-Origin");

		
		PrintWriter out = response.getWriter();//得到out对象
		out.println("{\"error\":0}");
		out.close();

如果客户端使用FormData提交，服务端需要在类名上加注解
//@MultipartConfig
public class AddServlet extends HttpServlet{}

Servlet就是一个Java类，遵守一定规范，必须运行在服务器端

用eclipse创建项目后 在src文件夹下建包后 包却不在src文件夹下：随便包名，src，项目名右键刷新

----------------------------------------------
cookie只是一个容器，session只是利用了cookie来存储令牌

web服务器只是简单的通过响应html页面来处理http请求

session里存的东西是一些重要信息               超时，令牌失效

默认cookie里JSessionId的值就是令牌

服务端操作令牌，浏览器只是保存，获取，发送令牌
令牌不光可以存在cookie里，请求头，请求参数里都可以进行存放

没登录和登录错误是一样的

超时三种设置：Tomcat 默认30分钟
	      web.xml session-config
	      setMaxInactiveInterval()

invalidate()做两件事：1，是JSessionId失效 2，把存储空间失效

sso-->单点登录    另一个子系统(权限服务器)维护登录状态，负责令牌发送

过滤器作用：1，拦截 2，通用操作

ServletRequest 是 HttpServletRequest的父接口

*的用法：1，/*代表一个路径下所有资源
	 2，*.do  *.html 特定路径下的资源

chain.doFilter()根据xml配置顺序去访问下一层

关于跨域或者请求和响应：浏览器发送请求，然后服务端返回响应信息，此时客户端根据响应回来的响应头处理是否允许跨域，也就是说，是否允许跨域由客户端来处理，服务端正常返回响应，然后浏览器根据Access-Control-Allow-Origin的值是否与请求头中的Origin值相同来决定是否处理响应信息，可做实验：在servlet类中输出，然后看浏览器中是否有响应，就可明白服务端确实执行了，并且做出了响应，但是浏览器拒绝处理该响应信息

关于ErrorFilter：前面throw了一个，后面的就不再执行了，然后在ErrorFilter里进行处理
例：10个throw，第5个抛出了，到第6个开始就不再执行了

每一次访问都会触发过滤器

上下文的attribute，request的attribute，session的attribute

tomcat 7.0 开始支持servlet3.0(出现七八年了)  servlet3.0是非阻塞的

<load-on-startup>决定执行顺序，在服务启动时就会对servlet进行启动和初始化，数字可以是不连续的，可以等于0，但不能小于

在new里直接创建servlet是基于3.0的，

过滤器的配置还是放在xml中比较好，用注解的话顺序是按名来的，有点坑

文件上传使用FormDate提交

路径跟着项目走

文件名变成随机的，是指只改变逻辑名，不改扩展名

WEB-INF和META-INF这两个文件夹下的内容是不可直接访问的

数据库里只存放图片的uri

同一个domain下的cookie会被整体提交到服务端，又被整体返回，不能进行限制哪个能交，哪个不能交
一个cookie对象只表示一个键值对
cookie安全性差，且只能存文本
getSession(fasle)如果已经有Session对象，返回这个session对象，没有，返回null；有令牌，返回session，没有令牌，返回null
传true和不传参，如果已经有session对象，返回这个session对象，没有，则创建一个，也就是说无论如何都会有一个session对象

session是服务器主动创建的，允许携带cookie，要在服务端加上允许跨域，和Access-Control-Allow-Origin:true ,然后在客户端加上axios.defaults.withCredentials=true(允许跨域ajax请求时携带cookie)，也可以加在单个axios中就是widthCredentials:true

发送cookie，在请求头里，为什么这样说呢？因为get提交没有请求体，而请求行又是固定的，所以只能在请求头里，键名为Cookie

第一次访问服务器的时候，服务端会检查有没有携带令牌，如果有携带并且令牌有效，找到对应的session，如果没有携带或令牌失效，会主动创建一个session(给一个ID)，然后把id值赋给名为JSessionId的cookie，之后再次访问，浏览器会携带这个cookie

第一次访问：1，没有携带cookie 2，有携带cookie，但没有令牌  3，有携带cookie，也有令牌

从客户端写入的cookie是不能提交到服务端的，只能提交服务端返回去的cookie信息，服务端写入的客户端才能再提交上来

public int insertDepts(List<Dept> depts){
		
		//不这么写，jdbc会自动提交事务，查询没有事务，增删改有事务；有一个失误，则全部提交失败，要成功就都成功
		String sql = "insert into dept values(?,?,?)";
		try {
			conn = super.getConn();
			//设定提交方式为非自动提交
			conn.setAutoCommit(false);
			int num = 0;
			for(Dept d : depts){
				stmt = conn.prepareStatement(sql);
				stmt.setInt(1, d.getDeptno());
				stmt.setString(2, d.getDname());
				stmt.setString(3, d.getLoc());
				num += stmt.executeUpdate();
			}
			//全部执行成功，手动提交事务
			conn.commit();
			return num;
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			//在catch中回滚
			try {
				conn.rollback();
			} catch (SQLException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			return -1;
		} finally{
			super.closeAll(conn, stmt, rs);
		}
	}


推送：1，轮询、长连接
      2，websocket: xhr2
		    tomcat78支持的方式不一样