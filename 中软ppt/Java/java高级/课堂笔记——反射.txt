java.lang.reflect.Constructor 类的每一个对象对应一个构造器 

java.lang.Class 类的对象代表程序中定义的每一个类/接口

java.lang.reflect.Method 类的对象代表程序中定义的每一个方法


获取类对象
三种方法:  1,Class c1 = Class.forName("com.usb.UsbDisk"); //此处跟类完整名
	   2,Class c2 = UsbDisk.Class; 
	   3,Class c3 = new UsbDisk().getClass();  //后两种方法值适用在类确定的情况下
有了class对象就可以知道该类的所有信息

getMethod()只返回有访问权限的属性

Object obj1 = c1.newInstance();   //调用无参的构造器创建对象  为什么产生异常：1，抽象类/接口/没有无参构造器

Object obj = c1.getConstructor(String.class).newInstance("abc")  //调用带参构造器创建对象

Method m = c1.getMethod("name");
m.invoke(obj);       不固定参数(实参可传任意多个):类型和参数名之间加 ... ，位置在形参列表之后 。不固定参数传的是参数类型，例:String.class

getMethod(方法名，形参列表);
invoke(调用方法的对象名，实参列表)
invoke(null,实参列表) 调用静态方法            invoke() 1+n个参数

属性：名字(类型不同，名相同的两个属性是不允许的)
方法：名字，形参列表
构造方法：形参列表                确定。。。



invoke()的返回值：表示方法执行的返回值，没有返回值则返回null  ，第一个参数看的是引用类型，而不是实例类型

用反射的前提：要操作的类是未知的，如果确定，就没必要用反射

――――――――――――――
内省：专门用来操作规范的，有封装的属性

实体类也可叫JavaBean

内省中判断一个属性的有无，是通过set/get的有无来判断的，二者有其一，则判断该属性存在，即使在程序中并没有该属性；
						       二者都没有，则判断该属性不存在，哪怕在程序中真的拥有该属性

setN() 只会在程序中寻找名字为小写n的属性

Object中有一个getClass()方法，内省就会认为Object中有一个class属性，尽管实际上Object并没有这个属性

Object --> json
1,获取所有属性并遍历
2，对不为null的属性拼接k:v
3，把所有的k:v拼接成json

json --> Object
1，拆解json 成K:v的格式，放到map集合中
2，遍历对象属性

Gson、Fast Json 、Jack Son 、Json Object

Gson的fromJson()只能处理单一层次的json，不能处理嵌套

gson.fromJson(jsonStr,class对象)

Properties文件里，=左边名字不能用驼峰命名法
=两边不能有空格，不加引号，没有分号，须得放在src根目录下


	gson格式：
		Map map = new LinkedHashMap();
		Map resMap = new LinkedHashMap();
		resMap.put("emps", list);
		map.put("errorCode", 0);
		map.put("result",resMap);
	      //Gson gson = new Gson();
		GsonBuilder gb = new GsonBuilder();
		gb.registerTypeAdapter(Date.class, new DateToStringAdapter());//目标类型，适配器对象
		Gson gson = gb.create();
		String jsonStr = gson.toJson(map);
		System.out.println(jsonStr);

在gson中如何处理日期：
public class DateToStringAdapter extends TypeAdapter<Date>{

	@Override
	public Date read(JsonReader arg0) throws IOException {
		
		return null;
	}

	@Override
	public void write(JsonWriter out, Date date) throws IOException {
		
		//String dateStr = DateFormat.getDateInstance().format(date);
		
		//out.value(dateStr);//参数就是格式化Json时的目标转换类型的值
		out.value(date.getTime());
	}

db.properties文件配置数据:
   db.driver=oracle.jdbc.driver.OracleDriver
   db.url=jdbc:oracle:thin:@localhost:1521:orcl
   db.name=scott
   db.pwd=orcl

BaseDao类中如何处理properties文件：
   private static final String DRIVER_CLASS;
	   private static final String DB_URL;
	   private static final String DB_NAME;
	   private static final String DB_PWD;
	   static{
		   Properties p = new Properties();
		   try {
			 //InputStream is = new FileInputStream(BaseDao.class.getResource("/db.properties").getPath());//获取bin文件夹下文件，类名是否本类不重要
			   InputStream is = BaseDao.class.getResourceAsStream("/db.properties");
			   p.load(is);
			   is.close();
		   } catch (FileNotFoundException e) {
			  
			   e.printStackTrace();
		   } catch (IOException e) {
			   
			   e.printStackTrace();
		   }
		   DRIVER_CLASS = p.getProperty("db.driver");
		   DB_URL = p.getProperty("db.url");
		   DB_NAME = p.getProperty("db.name");
		   DB_PWD = p.getProperty("db.pwd");
		
	   }


Dom4J的使用
   Document doc = new SAXReader().read(Test4j.class.getResourceAsStream("/web.xml"));
      Element element = doc.getRootElement();
      List<Element> list = element.elements();
      List<Web> newList = new ArrayList();
      for(Element e : list){
         Web web = new Web(e.element("url").getText(),e.element("servlet").getText());
        newList.add(web);
				 								
      }
  }