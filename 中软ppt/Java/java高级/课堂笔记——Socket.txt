XML
Dom解析和sas解析了解即可，常用Dom4j解析XML

属性和子节点可以互换，但子节点里还可以有子节点和属性
而属性里不能有其它东西

for --> 4 ; to --> 2 ; 4j --> for java

报文：第一行一定为请求/状态行，之后若干行为请求/响应头，直到空格结束

<form></form>里的<button></button>是同步的

get:请求参数
post:请求参数，formDate,json

跨域：由ajax请求访问造成

同源：请求的发送者和处理者是同一个ip，同一个端口
      或 客户端和服务端ip、端口完全一致

违反同源策略的访问叫做跨域访问

localhost和33.33.33.12或127.0,0.1都不算同一个源

只有早期的ajax才会有同源策略
xhr2可以不遵守同源策略

只有web端利用ajax请求时才会产生跨域问题，早期使用jsonp来解决

jsonp:只能用get提交，服务器无法识别客户端身份

访问的时候用的什么源，那么在服务端就把请求信息中的源提取出来，放到响应头中允许该源，这样就可以做到随便客户端从什么地址访问，服务端都会允许

也就是你请求用哪个源，我就允许你哪个源

在Accept后加一个：Access-Control-Allow-Origin:源

FormDate:1，利用现有表单提交，还可以额外追加其它数据
	 2，基于xhr2技术创新出来的东西，键对应的value可以使图片，文本和图片可以同时提交
	 3，提交进度可以进行监听

分享一定要用到请求参数，且必须用get提交

解决同源策略:1,JsonP 2,xhr2技术(增加Access-Control-Allow-Origin)

两个ServerSocket不能同时监听同一个端口

json格式会产生两次请求：
第一次请求方式为options，其服务端那边没有响应内容，为keep-alive(长连接)，没有请求体，事实上，除了post，其它请求方式都没有请求体。 相当于打个申请/报告，我一会要发数据，跟服务端沟通一个规则

第二次请求为post，有请求数据，为真正的请求

get 请求参数可以放在uri中
post的请求参数可以放在请求行中，也可以放在请求体中

post提交：例，vue中uri后跟请求参数，同时data中也有请求参数，那么此刻请求报文中请求行中有请求参数，请求体中也有请求参数

get没有Content-Type,POST有

Content-Type决定请求参数，响应内容的格式

三种创建线程的方式：1，继承Thread  2，实现runnable 3，lamda表达式，因为runnable是函数式接口

http：无状态，不会主动记录账户信息

cookies中信息，服务端可以修改，令牌存cookie中，cookie存客户端，服务端可以获取/修改cookie中信息

cookie被封装到请求头里

axios.defaults.withCredentials = true  允许跨域ajax请求时携带cookie

客户端的cookie不会被提交，连续存2次同样的cookie，会产生叠加，而不是替换
