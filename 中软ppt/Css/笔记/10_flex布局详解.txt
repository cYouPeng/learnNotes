弹性布局：

在容器上指定flex，这样其内部元素才能跟着走，flex之后就没有文档流这个概念了，
主轴有可能是横向的，也有可能是纵向的，交叉轴于其垂直相交
wrap-reverse交叉轴的反向操作

space-between 第一个和最后一个元素在两端，剩下平分间距，10个元素产生9个space
space-around 在第一个和最后一个元素，留半个space的间距，10个元素10个space

弹性布局 ，高度跟字号走  没写order就是0
缩小 按比例 设置为1
增加 按比例 按原比例来，也就是basis值的百分比
保持不变都为0

1 1 100px
2 1 200px
3 1 300px
扩大 缩小  都是按原比例


同一尺寸，分辨率高，字体应使用较大rem
视网膜屏，达到人眼极限分辨率的屏幕

flex-grow: 举个例子
container宽度为1000px，A,B,C三个子元素宽度为200px，flex-grow的值分别为1,2,3。此时剩余空间为400px，因为flex-grow的默认值为0，所以在没有设置flex-grow的情况下子元素
是不会自动扩张的。但现在设置了flex-grow，子元素将会按照各自flex-grow的值形成扩张比例。也就是说A扩张400 x 1/6 px ,再加上原有200px，扩张后总宽度达到了266px;
 B扩张 400 x 2/6 px 扩张后总宽度达到了333px; C扩张 400 x 3/6 px 扩张后总宽度达到了400px
 
flex-basis：等同于width  同时设置二者，以flex-basis为准，但是如果有一个的值为auto，那么就以另一个为准  用flex-basis更符合语义

flex-shrink：其实跟flex-grow的原理差不多，还是举个例子
	container宽度为800px，A,B,C三个子元素宽度为400px，flex-shrink的值分别为1,2,3。此时应该缩小的宽度为400px，flex-shrink的默认值为1，所以在没有设置flex-shrink的
	情况下子元素按等比例缩小。但现在设置了flex-shrink，子元素将会按照各自flex-shrink的值形成缩小比例。也就是说A缩小 400 x 1/6 px = 66px 然后A原本宽度400px-66px
	等于334px; B缩小 400 x 2/6 px = 133px 然后A原本宽度400px-133px等于267px; C缩小 400 x 3/6 px = 200px 然后A原本宽度400px-200px等于200px;
	
主轴沿逆时针方向旋转 90° 就得到了交叉轴

flex:1   //flex取值非负数  则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的：

.item {flex: 1;}
.item {
    flex-grow: 1;
    flex-shrink: 1;
    flex-basis: 0%;  //如果flex-basis不为0的话，那么扩张的长度就会在原本基础长度上增加，墨迹一点。。。
	/*假设有A，B，C三个子元素，我想让它们三各占三分之一，但是如果它们三的原本长度就不一样，这样就算它们三各增加了相同的长度，
	 *最后各自的比例也不是各占三分之一。。解决方法是把flex-basis设置为0，然后再根据flex-grow的比例进行分配，这样最后就达到了我们
	 *想要达到的完美比例
	*/
}

针对flex项目而言，box-sizing好象是不管用的


行内元素只能设置左右的margin padding  上下不管用

inline-block:将对象呈递为内联对象，但是对象的内容呈递为块级对象。旁边的内联对象会被呈递在同一行内，允许空格

block：默认屏幕上100%显示，同时还可以设定其大小
inline-block：默认原本大小显示，同时还可以设定其大小
inline：默认原本大小显示，同时不可以设定其大小



	