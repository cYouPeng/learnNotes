5，使用webpack打包编译css文件
	1，如何在项目中引入 .css 文件

		// index.js 文件
		console.log('我是 index.js 文件');
		require('./index.css')  // 引入 .css 样式文件
		require('./b.less')     // 引入 .less 样式文件

		/* index.css 文件 */
		body {
			background-color: red;
			color: yellow;
		}

		/* b.less 文件 */
		body {
			border: 5px solid #45454;
			div {
				font-size: 20px;
				font-weight: bolder;
			}
		}

	2，打包编译 .css 文件
		安装两个loader模块： css-loader 和 style-loader
			yarn add css-loader style-loader -D

		在 webpack.config.js 文件中进行配置
			plugins: [
				...
			],
			module: {       // 配置 webpack 使用到的模块
				rules: [
					{
						test: /\.css$/,     // 针对 .css 结尾的文件，使用下面的loader进行处理
						use: [
							'style-loader',
							'css-loader'
						]
					}
				],
			}
			test 属性是用来匹配文件的，一般我们使用正则表达式来匹配文件
			use 属性指定使用哪些程序，来对匹配到的文件进行处理，该属性是一个数组。这个数组中程序的顺序不能随便写，因为对文件进行处理的时候，webpack会按照从后向前的顺序，依次使用指定的程序来处理文件
			比如在处理index.css文件的时候，要先使用 css-loader 处理css语法，然后在使用 style-loader 将处理后的css挂载到 index.html 模板文件中
			该属性中不仅可以写字符串，还可以写对象，用来更深层次地配置处理文件的loader程序
			{
				test: /\.css$/,
				use: [
					{
						loader: 'style-loader',
						options: {
							insertAt: 'top'   // 将编译后的css挂载到模板文件的顶部
						}
					},
					'css-loader'
				]
			},
		配置完这些规则之后，使用 yarn dev 启动本地开发服务器或者使用 yarn build 对项目进行打包编译，webpack就可以顺利地使用我们配置的规则处理 .css 文件了

	3打包编译 .less 文件
		安装两个模块：less 和 less-loader
			yarn add less less-loader -D
		配置的方法
			module: {       // 配置 webpack 使用到的模块
				rules: [
					{
						test: /\.css$/,     // 针对 .css 结尾的文件，使用下面的loader进行处理
						use: [
							'style-loader',
							'css-loader'
						]
					},
					{
						test: /\.less/,
						use: [
							'style-loader',
							'css-loader',
							'less-loader'       // less-loader将less语法转成常规的css语法
						]
					}
				],
			}
		配置完成之后，重启开发服务器或者重新打包编译，.less 文件就可以顺利地被编译。

	4，将css代码抽离为单个文件
		如前面所提到的那样，webpack会打包编译 .css 文件或者 .less 文件，将处理后的css代码挂载到模板文件中，但是有的时候我们不希望这样。我们希望将处理后的css代码输出到一个指定的文件中，然后在模板文件中 自动引入 该文件,如果要达到这个目的，可以进行如下配置：

		首先安装一个插件 mini-css-extract-plugin
			yarn add mini-css-extract-plugin -D
		安装完成之后，直接进行如下配置即可
			let MiniCssExtract = require('mini-css-extract-plugin') // 引入插件
			...
			plugins: [      // 配置插件
				new HtmlWebpackPlugin({
					template: './src/index.html',
					filename: 'index.html',
					minify: {
						removeAttributeQuotes: true,
						collapseWhitespace: true
					},
					hash: true
				}),
				new MiniCssExtract({        // 创建该插件的实例
					filename: 'main.css'    // 指定输出的css文件的文件名  默认是main.css
				})
			],
			module: {
					rules: [
						{
							test: /\.css$/,
							use: [
								MiniCssExtract.loader,   //不再使用style-loader把css挂载到模板文件上，使用MiniCssExtract.loader把css提取到main.css中
								'css-loader'
							]			
						},
						{
							test: /\.less$/,
							use: [
								MiniCssExtract.loader,
								'css-loader',
								'less-loader'
							]
						}
					]										
				}
		配置完成之后，直接 yarn build 进行打包编译项目，就会得到一个 main.css 文件
			/* main.css 文件 */
			body {
				color: yellow;
			}
			body {
				background-color: gray;
				transform: rotate(45deg)    /* 注意这一行css3代码，没有添加前缀，后面会提到 */
			}
			body {
			  border: 5px solid #4545 4;
			}

	5，给打包编译后的css属性添加相关前缀
		安装两个模块： postcss-loader 和 autoprefixer
			yarn add postcss-loader autoprefixer -D
		配置
			module: {
				rules: [{
						test: /\.css$/,
						use: [
							MiniCssExtract.loader,
							'css-loader',
							'postcss-loader'        // 给CSS3属性添加前缀
						]
					},
					{
						test: /\.less$/,
						use: [
							MiniCssExtract.loader,
							'css-loader',
							'less-loader',
							'postcss-loader'        // 给CSS3属性添加前缀
						]
					}
				]
			}
		在上面代码中，我们指定了使用 postcss-loader 来处理 .css 和 .less 文件，但是现在webpack还不能自动给CSS3属性添加前缀，我们还需要进行配置postcss-loader。在项目根目录下创建 postcss.config.js 文件，在里面书写以下配置代码即可：
			module.exports = {
				plugins: [
					require('autoprefixer')
				]
			}
		这个时候打包编译，webpack就可以自动给CSS3属性添加前缀了
			/* main.css 文件 */
			body {
				background-color: gray;
				-webkit-transform: rotate(45deg);
						transform: rotate(45deg)
			}

	6压缩编译后的 .css 文件
		我们可以看到，抽离出来的 main.css 文件没有进行压缩，但是很多项目在打包的时候，都需要对 .css 文件进行压缩以节省体积。要达到这个目的，可以进行如下配置
		首先安装一个插件：optimize-css-assets-webpack-plugin
			yarn add optimize-css-assets-webpack-plugin -D
		安装完成之后，直接在 webpack.config.js 进行如下配置即可
			let OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');    // 引入插件
			module.exports = {
				optimization: {                         // 配置webpack的优化项
					minimizer: [                        // 配置最小值优化项
						new OptimizeCSSAssetsPlugin()   // 声明css优化插件的实例
					]
				},
				mode: "production",                     //此处必须是production模式，development模式main.css不会被压缩
				entry: "./src/index.js", 
				...
			
			
		配置完成之后，再次进行打包编译项目，就会得到被压缩的 main.css 文件

		虽然我们指定webpack的模式为 生产模式（production）,该模式下，打包后的 .js 文件本应该被压缩，但是实际的情况却不是这样，得到的 .js 文件没有被压缩

		这是因为我们在配置 webpack优化项（optimization） 的时候，一些优化配置会覆盖webpack的默认配置。我们这里没有在optimization指定压缩 .js 文件，所以即使是在生产模式下进行打包编译，最后得到的 .js 文件依然是没有被压缩的。

		如果要对 .js 文件进行压缩，配置如下：
		安装一个插件：terser-webpack-plugin
			yarn add terser-webpack-plugin -D
		和上面类似的配置
			let TerserJSPlugin = require('terser-webpack-plugin');      // 引入插件
			optimization: {                         // 配置webpack的优化项
			minimizer: [                            // 配置最小值优化项
					new OptimizeCSSAssetsPlugin(),
					new TerserJSPlugin()            // 声明js压缩插件的实例
				]
			},
		现在再次进行打包，得到的 .js 文件就是被压缩的。




