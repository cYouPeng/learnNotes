干股只能分红不能买卖，卸职以后就要收回
   
  <div title="hello"></div>  任何元素都可以加title属性，鼠标悬浮其上会显示额外信息
  
  var obj = {
	foo: 'bar'
  }

  Object.freeze(obj)   //阻止修改现有的属性
  obj.foo = 'hello'    //会报错
  
  <div v-bind:hello="a" >中国</div>  //如果a的值为null,undefined或false，那么该hello特性不会出现在div中
  <div :[attri]="a"></div>   //从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：动态参数
  
  js的全局变量本来就是同一页面上所有script脚本公用的，你要注意js文件的加载顺序
  ps： 只能同一页面，不能跨页面
  
  
  vue-resource是一个非常轻量的用于处理HTTP请求的插件
  vue2.0之后，就不再对vue-resource更新，而是推荐使用axios。基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 Node.js 中使用
  
  
  cli:command line interface 命令行接口
  
  如何创建.babelrc文件   命令行中 echo  > .babelrc   //echo后是两个空格			 
  
  浅拷贝和深拷贝只针对于引用数据类型
  浅拷贝：只复制对象的引用地址，此时两个变量指向同一块内存
  深拷贝：申请一块新的内存，把对象中的所有值都复制过去，此时两个变量指向两块地址不同的内存
	1，slice()、concat、... 操作符：只能实现一维数组的深拷贝
						let arr1 = [1, [2, 3]];
						let arr2 = arr1.slice() / [...arr1] / [].concat(arr1)
						arr2[0] = 9;
						arr2[1][0] = 8;
						console.log(JSON.stringify(arr1))  //[1,[8,3]]
						console.log(JSON.stringify(arr2))  //[9,[8,3]]

	2，Object.assign()：只能实现一维对象的深拷贝
						let obj1 = {
							x: 'hello',
							y: {
								z: 'world'
							}
						}
						let obj2 = Object.assign({}, obj1);
						obj2.x = 'olleh'
						obj2.y.z = 'dlrow'
						console.log(JSON.stringify(obj1))  //{"x":"hello","y":{"z":"dlrow"}}
						console.log(JSON.stringify(obj2))  //{"x":"olleh","y":{"z":"dlrow"}}
	
	进行JSON.stringify()序列化的过程中，undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。
		 let obj = {
            a: 123,
            b: undefined,
            c(){
                console.log(11)
            },
            d:Symbol("haha"),
            e: 'cyp'
        }
        console.log(JSON.stringify(obj))  //{"a":123,"e":"cyp"}
		
        let arr = [12, undefined, function(){}, Symbol('ha'), 'cyp'];
        console.log(arr);  //(5) [12, undefined, ƒ, Symbol(ha), "cyp"]
        console.log(JSON.stringify(arr));  //[12,null,null,null,"cyp"]

	3，JSON.parse(JSON.stringify(obj))：可实现多维对象的深拷贝，但会忽略undefined、任意的函数、symbol 值
		let obj = {
            a: 123,
            g: {
                m: '999'
            },
            b: undefined,
            c(){
                console.log(11)
            },
            d:Symbol("haha"),
            e: 'cyp'
        }
        let obj2 = JSON.parse(JSON.stringify(obj));
        obj2.g.m = 888;
        console.log(obj)  //{a: 123, g: {m: "999"}, b: undefined, d: Symbol(haha), c: ƒ, …}
        console.log(obj2); //{"a":123,"g":{"m":888},"e":"cyp"}
	
	
	
  es6之扩展运算符(...)
	扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中
		-对象的扩展运算符
			let bar = { a: 1, b: 2 };
			let baz = { ...bar }; // { a: 1, b: 2 }
		  上述方法实际上等价于:
			let bar = { a: 1, b: 2 };
			let baz = Object.assign({}, bar); // { a: 1, b: 2 }
			
			Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
			Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)
	
			同样，对于扩展运算符而言，如果有同名属性，后面也会覆盖前面的
				let bar = {a: 1, b: 2};
				let baz = {...bar, ...{a:2, b: 4}};  // {a: 2, b: 4}
	
		-数组的扩展运算符
			-可以将数组转换为参数序列
				function add(x, y) {
				  return x + y;
				}

				const numbers = [4, 38];
				add(...numbers) // 42
			-可以复制数组		
				const arr1 = [1, 2];
				const arr2 = [...arr1];
	
		//个人觉得，扩展运算符只是把对象中所有可遍历属性给取了出来，至于后续的复制等动作是我们来做的，而不是扩展运算符来做的
		//rest参数是把参数序列转为数组，把所有苹果放到一个篮子里
		//扩展运算符是把数组转为参数序列，当然它也可应用于对象，但说它是rest参数的逆运算并不算错误。把篮子里的苹果给取出来
		
		const [first, ...rest] = [1, 2, 3, 4, 5]  //此处为rest参数和解构赋值的结合使用，下标为0的元素赋给first变量，剩下的参数序列赋值给rest参数
        console.log(first)  //1
        console.log(Array.isArray(rest)) //true
		
		等同于：
		const arr = [1, 2, 3, 4, 5]  
        const first = arr[0];
        const rest = arr.slice(1);
        console.log(rest)
	
	
	then方法返回一个Promise，而它的行为与then中的回调函数的返回值有关
		-如果then中的回调函数返回一个值，那么then返回的Promise将会成为成功状态，
		 并且将返回的值作为新Promise对象的成功状态的回调函数的参数值
		-如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为失败状态，
		 并且将抛出的错误作为新Promise对象的失败状态的回调函数的参数值
		-如果then中的回调函数返回一个已经是成功状态的Promise，那么then返回的Promise
		 也会是成功状态，并且将那个Promise传出的参数值作为新Promise的成功状态的回调函数
		 的参数值
		-如果then中的回调函数返回一个已经是失败状态的Promise，那么then返回的Promise
		 也会是失败状态，并且将那个Promise传出的参数值作为新Promise的失败状态的回调函数
		 的参数值
		-如果then中的回调函数返回一个初始状态的Promise，那么then返回的Promise也会是
		 初始状态，并且它的终态与那个Promise的终态相同；同时，那个Promise变为终态时传出
		 的参数值作为新Promise变为终态时调用的回调函数的参数值
	
		一，
			let promise = new Promise((resolve, reject) => {
				setTimeout(() => {
					reject()
				}, 1000)
			})
			promise.then(() => {
				return 123
			}, (val) => {
				return 456
			}).then((val) => {
				console.log("succ"+val)
			}, (val) => {
				console.log("err"+val)
			})
		    // succ456
			
		二，
			let promise = new Promise((resolve, reject) => {
				setTimeout(() => {
					reject()
				}, 1000)
			})
			promise.then(() => {
			   return 123
			}, (val) => {
				throw new Error('faild')
			}).then((val) => {
				console.log("succ"+val)
			}, (val) => {
				console.log("err"+val)
			})
			// errError: faild
			
		三，
			let promise = new Promise((resolve, reject) => {
				setTimeout(() => {
					reject()
				}, 1000)
			})
			promise.then(() => {
			   return 123
			}, (val) => {
				return new Promise((resolve, reject) => {
					resolve('cyp')
				})
			}).then((val) => {
				console.log("succ"+val)
			}, (val) => {
				console.log("err"+val)
			})
			// succcyp
			
		四，
			let promise = new Promise((resolve, reject) => {
				setTimeout(() => {
					reject()
				}, 1000)
			})
			promise.then(() => {
			   return 123
			}, (val) => {
				return new Promise((resolve, reject) => {
					reject('cyp')
				})
			}).then((val) => {
				console.log("succ"+val)
			}, (val) => {
				console.log("err"+val)
			})
			// errcyp
			
		五，
			let promise = new Promise((resolve, reject) => {
				setTimeout(() => {
					reject()
				}, 1000)
			})
			promise.then(() => {
			   return 123
			}, (val) => {
				return new Promise((resolve, reject) => {
					setTimeout(() => {
						reject('cyp')
					}, 3000)
					
				})
			}).then((val) => {
				console.log("succ"+val)
			}, (val) => {
				console.log("err"+val)
			})
			// errcyp
	
	
	
单选框radio和复选框checkbox
<form>
	a1:  <input type="checkbox" name="apple" value="a1" />
	a2:  <input type="checkbox" name="apple" value="a2" />
	<input type="submit" value="提交">
</form>	

	全都打勾，点击提交时：xxx?apple=a1&apple=a2，由此可以看到name和value的作用体现在提交表单时，radio也是如此。
	单选框和复选框不写value，则提交表单时value值默认为on
	文本框写不写value都是不影响的，但必须要写name
	
	至于你想控制对号的显示，则需要操作的是 checked 属性
	
	他们的value和文本框的value是不一样的，文本框的value不光会出现url后的参数中，还会显示在界面中
		
	有一点要注意，不管是文本框，单选框，复选框都必须要有name属性，否则提交表单时不会添加到参数中



onchange  要在input内容发生改变，并且失去焦点时才会触发，可用于<input>, <select>, 和 <textarea>
oninput   在用户输入时触发，它是在元素值发生变化时立即触发，可用于<input>, <textarea>
onblur    在元素失去焦点时触发
onfocus   在元素获得焦点时触发

对于单选框和复选框来说，onchange和oninput事件的效果是一样的

例：
    <input @change="cc($event.target.value)" />
    <input @blur="cc($event.target.value)" />
    <input @input="cc($event.target.value)" />
	
	
	
下拉框
	<select  id="sel">
        <option value="aaa">A</option>
        <option>B</option>
        <option>C</option>
    </select>
	option没有value属性，那么下拉框的value就是<option>包裹的内容
	option有value属性，那么下拉框的value就是这个option value属性的值，<option>包裹的内容仅是展示用
	
	也就是说，有value就用value，没有就用包裹的内容
	
	
let {name: name2, age="123"} = {name: "jack"}
console.log(name)  // 空串
console.log(name2) //jack
console.log(age)  //默认值123   可以用es6中的参数默认值来为解构对象中没有对应属性的变量提供默认值
这种形式可以使用另一个变量来接收name的值，但注意此时就不能再使用name了，它会是一个空串
此处为解构赋值两个知识点：1，重命名  2，默认值



Polyfill 是一块代码（通常是 Web 上的 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。

比如说 polyfill 可以让 IE7 使用 Silverlight 插件来模拟 HTML Canvas 元素的功能，或模拟 CSS 实现 rem 单位的支持，或 text-shadow，或其他任何你想要的功能。


MVVM      M: model 模型   后端传来的数据   
		  V: view 视图    显示的页面
          VM: view model 视图模型
		  在MVVM的框架下view和model是不能直接通信的，需借助ViewModel进行通信
		  当model发生变化，ViewModel会监听到这种变化，然后通知view做相应的改变
		  当view发生变化，ViewModel会监听到这种变化，然后通知model做相应的改变
		  这实际上就实现了数据的双向绑定

浏览器的兼容性问题已经不再是前端的阻碍。前端的项目越来越大，项目的可维护性和扩展性、安全性等成了主要问题。  

Object.keys(obj) 方法会返回一个由给定对象自身可枚举属性组成的数组

return str.charAt(0).toUpperCase() + str.slice(1)

沿着作用域链找，没找到，会报错
沿着原型链找，没找到，会是undefined



使用 逻辑运算符(或、与) 返回的值都是你运算时用的值，逻辑运算符 运算后的结果不会自动转换成 布尔值。
注：非运算 除外 (非运算会自动转换成布尔值)
平常在if() 语句中, 只不过if括号中的值 会自动转换为布尔值




Array.forEach  就是很普通的遍历，什么都不返回

Array.filter 对数组每一项运行给定函数，把对返回true的项添加到新数组里，最后返回新数组
Array.map 	 对数组每一项运行给定函数，把每次函数返回的结果添加到新数组里，最后返回新数组

Array.some   对数组每一项运行给定函数，有任一项返回true，则结果就为true
Array.every  对数组每一项运行给定函数，每一次该函数都返回true，则结果才为true

[1,2,3].filter((item, index. arr) => {...})  ((item, index) => {...})  (item => {...})    item 必需  index, arr 可选 

Array.find  对数组每一项运行给定函数，当函数返回true时，返回该项值，函数结束运行。没有返回true的项，则返回undefined
			对于空数组则不会执行
			[1,2,3].find((item, index, arr) { return item > 2 })   item 必需  index, arr 可选 
			
array.findIndex(function(currentValue, index, arr), thisValue)   只有currentValue是必需的，其它三个参数可选
返回数组中第一个符合条件的元素的位置，然后停止执行。没有找到则返回-1
[12,14,90].findIndex(currentValue => currentValue > 18)



| （竖线） 用于括号或大括号里，只能选一个 
[ ] （方括号） 可选可不选  
{}（大括号） 选一个 
<> 必选
[ ,...n ] 表示前面的项可重复 n 次。每一项由逗号分隔。 
[ ...n ] 表示前面的项可重复 n 次。每一项由空格分隔


表单元素的 disabled 的值为true，表示禁用该元素；值为false，表示启用该元素

浏览器宿主环境中有window全局对象；node宿主环境中有global全局对象


array.includes(searchElement, fromIndex) 方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false
	searchElement: 必需，查找的值
	fromIndex：可选，从哪里开始找  如果fromIndex 大于等于数组长度 ，则返回 false 。该数组不会被搜索
		var arr = ['a', 'b', 'c'];
 
		arr.includes('c', 3);   //false
		如果fromIndex小于 0，则整个数组都会被搜索。
		arr.includes('c', -3);   //true


localStorage和sessionStorage：
	localStorage 生命周期为永久，除非用户显式清除，否则信息一直存在。无论你重启多少次浏览器
	sessionStorage 生命周期为当前标签，当前标签关闭，信息也被清空
	
	localStorage.clear()  //清除全部信息
	localStorage.getItem() //获取指定key信息
	localStorage.setItem() //设置信息
    localStorage.removeItem() //移除指定key信息
	localStorage.length //获取信息个数
	常用方法(同样适用于sessionStorage)
	
localStorage.token = 'helloworld'    //也可以这样保存、读取
alert(localStorage.token)
	
Object.keys(obj)  返回一个表示给定对象的所有可枚举属性的字符串数组

	let person = {name:"张三",age:25,address:"深圳",getName:function(){}}
	Object.keys(person) // ["name", "age", "address","getName"]
	常用：
	Object.keys(person).map((key)=>{
	　　person[key] // 获取到属性对应的值，做一些处理

	}) 	

reduce 可以对数组进行遍历，但它会将每次遍历的结果传到下一轮回调中，最后一次回调的结果会被返回
arr.reduce(function(prev,cur,index,arr){
	...
}, init);
prev 表示上一次回调的返回值，或者初始值 init
cur 表示当前正在处理的数组元素
index 表示当前正在处理的数组元素的索引，若提供 init 值，则索引从0开始，否则从1开始
arr 表示原数组

	原始数组
	var arr = [3,9,4,3,6,0,9];
	
	1. 求数组项之和
		var sum = arr.reduce(function (prev, cur) {
			return prev + cur;
		},0);
		由于传入了初始值0，所以开始时prev的值为0，cur的值为数组第一项3，相加之后返回值为3作为下一轮回调的prev值，然后再继续与下一个数组项相加，以此类推，直至完成所有数组项的和并返回
		
	2. 求数组项最大值
		var max = arr.reduce((prev, cur) => {
			return Math.max(prev, cur)
		})
		由于未传入初始值，所以开始时prev的值为数组第一项3，cur的值为数组第二项9，取两值最大值后继续进入下一轮回调。
	
	3. 数组去重
		var newArr = arr.reduce(function (prev, cur) {
			prev.indexOf(cur) === -1 && prev.push(cur);
			return prev;
		},[]);
		初始化一个空数组
		在初始化数组里查找当前项，找不到，把当前项添加到初始化数组中
		然后初始化数组作为下一轮回调的prev值，继续查找
		最后返回初始化数组
		
$num指第num个匹配值
匹配值指正则中的pattern也就是括号部分	
	modulePath.replace(/^\.\/(.*)\.\w+$/, '$1')
	匹配到 ./app.js  使用第一个括号的匹配值进行替换  ./app.js  => app
	
String.fromCharCode()  将 Unicode 编码转为一个字符
	- 可接受一个指定的 Unicode 值，然后返回一个字符串
		var n = String.fromCharCode(65);  // A
		
stringObject.charCodeAt(index) 返回指定位置的字符的 Unicode 编码
	- 字符串中第一个字符的下标是 0。如果 index 是负数，或大于等于字符串的长度，则 charCodeAt() 返回 NaN
		var str="Hello world!";
		console.log(str.charCodeAt(1)); // 101


Unix时间戳(Unix timestamp)是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。Unix时间戳不仅被使用在Unix系统、类Unix系统中(比如Linux系统)，也在许多其他操作系统中被广泛采用

通过路由的meta标签对需要做校验的路由页面进行标记
	{
	  path: '/userInfo',
	  name: 'userInfo',
	  meta: {
		requireAuth: true,  // 该路由项需要权限校验
	  }
	  component: userInfo
	}, {
	  path: '/userList',
	  name: 'userList',    // 该路由项不需要权限校验    
	  component: userInfo
	}
之后，我们可以定义一个路由守卫，每次路由跳转，都来做一下权限校验
	router.beforeEach((to, from, next) => {
	  if (to.meta.requireAuth) {  // 判断该路由是否需要登录权限
		if (localStorage.token) {  // 获取当前的token是否存在
		  console.log("token存在");
		  next();
		} else {
		  console.log("token不存在");
		  next({
			path: '/login', // 将跳转的路由path作为参数，登录成功后跳转到该路由
			query: {redirect: to.fullPath}
		  })
		}
	  }
	  else { // 如果不需要权限校验，直接进入路由界面
		next();
	  }
	});

location 对象包含有关当前 URL 的信息，location 对象是 window 对象的一部分
	-hash 返回一个URL的锚部分
		console.log(location.hash) // #/documentation/index
	-host 返回一个URL的主机名和端口
		console.log(location.host) // localhost:9527
	-hostname 返回URL的主机名
		console.log(location.hostname) // localhost
	-href 返回完整的URL
		console.log(location.href) // http://localhost:9527/#/documentation/index
	-port 返回一个URL服务器使用的端口号
		console.log(location.port) // 9527
	-protocol 返回一个URL协议
		console.log(location.protocol) // http:
	-search 返回一个URL的主机名和端口
	
	-assign() 载入一个新的文档
	-replace() 用新的文档替换当前文档
	-reload() 刷新当前页面。该方法只有一个参数，当值为 true 时，将强制浏览器从服务器加载页面资源，当值为 false 或者未传参时，浏览器则可能从缓存中读取页面。
		location.reload()
		
CORS 的基本思想就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求响应是应该成功还是应该失败
当Http请求发起会带着以下请求头信息
	Origin:http://www.csdnblog.com
返回头也会夹带着类似如下信息
	Access-Control-Allow-Credentials:true 
	Access-Control-Allow-Origin:http://www.csdnblog.com
如果返回头中没有这个头部，或者有头部但是源信息不匹配。那么浏览器就会帮我们驳回这次请求，同源策略在这里发挥了作用

+new Date()  注意 + 号，可以返回时间戳


觉得好看的背景色 #2c343c

npm run build -- --config webpack.config.my.js  使用 npm run 后面想指定配置文件，需要加上 --

如果你想某个请求基于不同的 baseURL，可以在请求内部设置 baseURL，它会覆盖创建实例时的 baseURL
export function getInfo(token) {
  return fetch({
    baseURL: https://api2-xxxx.com
    url: '/user/info',
    method: 'get',
    params: { token }
  });
}

webpack4 的 style-loader   insertAt 改为 insert
postcss.config.js 必须得设置支持的浏览器才会自动添加前缀
	module.exports = {
	  plugins: {
		  'autoprefixer': {overrideBrowserslist: ['> 1%', 'last 2 versions']}
	  }
	}
	
	
vue脚手架如何使用 echarts 和 百度地图
1, 安装 echarts
	npm i echarts
2, 在 public 下的 index.html 中声明秘钥
	<script type="text/javascript" src="http://api.map.baidu.com/api?v=3.0&ak=秘钥"></script>
3, 引入 echarts 和 百度地图扩展
	import echarts from 'echarts'
	import 'echarts/extension/bmap/bmap'



//取消百度地图左下角图片标识  App.vue
.BMap_cpyCtrl {
  display: none;
}
.anchorBL {
  display: none;
}
	
type: scatter
emphasis: {
	label: {
		show: false   //并没卵用
	}
}

label: {
	...样式  //普通状态下的样式
}
itemStyle: {
	...样式   
}
emphasis: {   //它俩的高亮样式统一在这里写
	label: {
		...样式
	},
	itemStyle: { 
		...样式   
	}
}

mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick
mounted: function () {
  this.$nextTick(function () {
    // Code that will run only after the
    // entire view has been rendered
  })
}


字符串和花括号之间一定不要存在空格，否则会导致识别失败
<checkbox checked=" {{isCheced}}"></checkbox>  // worong

wx:for="{{数组或者对象}}" wx:for-item="循环项的名称"默认为 item    wx:for-index="循环项的索引" 默认为index
wx:key="唯一的值" 用来提高列表渲染的性能
  1 wx:key 绑定一个普通字符串的时候 那么这个字符串名称 肯定是 循环数组中的对象的唯一属性
  2 wx:key="*this" 就表示 你的数组是一个普通的数组 *this 表示循环项
	[1,2,3,4]
	["apple", "3333", "abc"]
对象循环
  1 wx:for="{{对象}}" wx:for-item="对象的值" wx:for-index="对象的属性"
  2 循环对象的时候 最好把 item和index的名称都修改一下
	wx:for-item="value" wx:for-index="key"
	
block
  1 占位符的标签
  2 写代码的时候 可以看到这标签存在
  3 页面渲染 小程序会把它移除掉
  4 我觉得相当于 vue里的 template
  
<view wx:if="{{false}}">1</view>
<view wx:elif="{{true}}">2</view>
<view wx:else>3</view>

<view hidden>1</view>  //直接写属性也可以
<view hidden="{{true}}">1</view>

wx:if 和 hidden 的区别 相当于 v-if和v-show
hidden 不要和 display 一起使用  因为会把 hidden的display覆盖掉

小程序中对闭合标签比较严格
	<input type="text" >  wrong  必须加 / 
	<input type="tex" />	

1 需要给input标签绑定 input 事件
 绑定关键字 bindinput
2 如何获取输入框的值
 通过事件源对象来获取
 e.detail.value
3 把输入框的值赋值到 data 当中
 不能直接
  1 this.data.num = e.detail.value
  2 this.num = e.detail.value
 正确的写法
  this.setData({
	num: e.detail.value
  })
  获取data中的值可以直接：this.data.num
4 需要加入一个点击事件
 1 bindtap
 2 无法在小程序的事件当中直接传参
	<button bindtap="handletap(1)"></button> wrong 此时小程序会把 handletap(1) 当做事件名
 3 通过自定义属性的方式来传递参数
	<button bindtap="handletap" data-operation="{{1}}"></button>
	必须以data-开头，否则无法在事件对象中获取该属性的值
 4 事件源中获取自定义属性
	const operation = e.currentTarget.dataset.operation

1 小程序中 不需要主动引入样式文件  规定屏幕宽为750rpx
2 需要把页面中某些元素的单位 由 px 改成 rpx
	1 设计稿 750px
		750px = 750rpx
		1px = 1rpx
	2 把屏幕宽度 改成375px
		375px = 750rpx
		1px = 2rpx
		1rpx = 0.5px
	3 存在一个设计稿 宽度414 或者未知 page
		1 设计稿 page 存在一个元素 宽度 100px
		2 拿以上的需求 去实现不同宽度的页面适配
		
		page px = 750rpx
		1px = 750rpx / page
		100px = 750rpx * 100 / page
		假设 page = 375px
	4 利用一个属性 calc 属性 css和wxss 都支持这个属性
		1 750和rpx 中间不要留空格
		2 运算符的两边要留空格
		
	view{
		/* width: 200rpx; */
		height: 200rpx;
		font-size: 40rpx;
		background-color: aqua;
		/* 以下代码写法错误 */
		/* width: 750rpx * 100 /375; */
		width: calc(750rpx * 100 / 375);
	}
	
使用 @import 语句可以导入外联样式表，只支持相对路径
@import "../../styles/common.wxss";
/* common wxss */
.middle p {
	padding: 15px;
}
 
小程序不支持通配符 * ，因此以下代码无效
	*{
		margin: 0
	}
支持的选择器有：
	.class    .intro
	#id       #firstname
	element   view
	element,element  view,checkbox
	nth-child(n)  view:nth-child(n)
	::after       view::after
	::before      view:
	
原生小程序不支持less
	vscode 安装 easy less 插件
	在vscode的配置中加入如下
	"less.compile": {
		"outExt": ".wxss"
	}
	在要编写样式的地方，新建 less 文件，正常编辑即可，这个插件会自动把less转成wxss
	less天生支持 @import 导入，写法同上
	
view 相当于div标签
text 相当于span标签
	只能嵌套text
	长按文字可以复制（只有该标签有这个功能）
		selectable boolean false 文本是否可选
		<text selectable>abc</text>
	可以对空格回车进行编码
		decode boolean false  是否解码
		<text>&nbsp;</text> //原样输出 &nbsp;
		<text decode>&nbsp;&lt;</text> //可以输出空格
		
腾讯规定小程序打包上线的大小不能超过2M，所以最好使用web图片
image组件默认宽度320px, 高度240px   支持懒加载
	  
	  1 src 指定要加载的图片的路径
	  2 mode 决定 图片内容如何和图片标签宽高做适配
		1 scaleToFill 默认值 不保持纵横比缩放图片，使图片的宽高完全拉伸至填满image元素
		2 aspectFit 保持宽高比 确保图片的长边显示出来 页面轮播图常用
		3 aspectFill 保持纵横比缩放图片，只保证图片的短边能完全显示出来 少用
		4 widthFix 以前web图片的宽度指定了之后，高度会自己按比例调整  常用
		5 top bottom... 类似以前的background-position
	  3 小程序当中的图片 直接就支持 懒加载 lazy-load
	    1 lazy-load 会自己判断当图片出现在视口上下三屏的高度之内的时候，自己开始加载图片
		<image mode="bottom" lazy-load src="..." />
		
1 轮播图外层容器 swiper
2 每一个轮播项 swiper-item
3 swiper标签 存在默认样式
 1 width 100%
 2 height 150px    image存在默认宽度和高度 320*240
 3 swiper 高度 无法实现由内容撑开
 4 先找出来 原图的宽度和高度 等比例 给swiper定宽度和高度
   原图的宽度和高度 1125 * 252 px
   swiper 宽度 / swiper 高度 = 原图的宽度 / 原图的高度
   swiper 高度 = swiper 宽度 * 原图的高度 / 原图的宽度
   height = 100vw * 352 / 1125
 5 autoplay 自动轮播
 6 interval 修改轮播时间
 7 circular 衔接轮播
 8 indicator-dots 显示指示器 分页器 索引器
 9 indicator-color 指示器的未选择的颜色
10 indicator-active-color 选中的时候的指示器的颜色

   
   <swiper autoplay interval="1000" indicator-dots indicator-color="#0094ff" indicator-active-color="#ff0094">
	<swiper-item><image mode="widthFix" src="..."></swiper-item>
	<swiper-item><image mode="widthFix" src="..."></swiper-item>
	<swiper-item><image mode="widthFix" src="..."></swiper-item>
   </swiper>
   swiper{
	width: 100%;
	height: calc(100vw * 352 / 1125);
	/* height: 31.28vw */
   }
		
	
	
	
	
	
	
	
	
	
	
	
	
 
 
以前的多页面站点是在服务端渲染的，输出到浏览器时已经有了完整的骨架（ html ），这样爬虫抓到时可以分析页面标题，内容等等，做 seo 容易，那时的技术栈是 jsp，php 等等。现在流行的前端框架在这方面是开了倒车，一个空的骨架，一个很大的 js，抓到浏览器以后才开始渲染完整的页面，爬虫就很为难了，因为它没法执行 js 啊，此外，白屏时间也是由于前端渲染带来的问题。于是又有了服务端渲染，让渲染这一步再回到服务端，在服务端模拟浏览器环境，给 react 和 vue 等框架一个可执行的上下文，就是为了提前得到完整的 html


[1,2,3].concat(4,5)    // [1,2,3,4,5] 	参数序列
[1,2,3].concat([4,5])	// [1,2,3,4,5]	数组
[1,2,3].concat({name: 'Jack'})  //[1,2,3,{name: 'Jack'}]  对象    都是返回一个新的数组

[1,2,3].concat(4,5,[6,7],{name: 'Jack'})  //[1, 2, 3, 4, 5, 6, 7, {name: 'Jack'}]  //也可以混着放在一起


let a = 'aaa';
var b = 'bbb';
console.log(window.a,window.b)  // undefined "bbb" 

let 声明的变量不会跟 var 一样作为 window 对象的属性


<el-input v-model="formDataCopy.ProvidentFundDetails[index].Base" maxlength="12" @input="changeNumber(index)" />
changeNumber(index) {
  this.formDataCopy.ProvidentFundDetails[index].Base = (this.formDataCopy.ProvidentFundDetails[index].Base.match(/^\d*(\.?\d{0,2})/g)[0]) || null
},
12位数字，小数点后最多两位

<el-input v-model="formDataCopy.ProvidentFundAccount" oninput="value=value.replace(/[^\d]/g,'')" maxlength="12" /> 
只能输入数字








