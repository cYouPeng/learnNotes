干股只能分红不能买卖，卸职以后就要收回
   
  <div title="hello"></div>  任何元素都可以加title属性，鼠标悬浮其上会显示额外信息
  
  var obj = {
	foo: 'bar'
  }

  Object.freeze(obj)   //阻止修改现有的属性
  obj.foo = 'hello'    //会报错
  
  <div v-bind:hello="a" >中国</div>  //如果a的值为null,undefined或false，那么该hello特性不会出现在div中
  <div :[attri]="a"></div>   //从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：动态参数
  
  js的全局变量本来就是同一页面上所有script脚本公用的，你要注意js文件的加载顺序
  ps： 只能同一页面，不能跨页面
  
  
  vue-resource是一个非常轻量的用于处理HTTP请求的插件
  vue2.0之后，就不再对vue-resource更新，而是推荐使用axios。基于 Promise 的 HTTP 请求客户端，可同时在浏览器和 Node.js 中使用
  
  
  cli:command line interface 命令行接口
  
  如何创建.babelrc文件   命令行中 echo  > .babelrc   //echo后是两个空格			 
  
  浅拷贝和深拷贝只针对于引用数据类型
  浅拷贝：只复制对象的引用地址，此时两个变量指向同一块内存
  深拷贝：申请一块新的内存，把对象中的所有值都复制过去，此时两个变量指向两块地址不同的内存
	1，slice()、concat、... 操作符：只能实现一维数组的深拷贝
						let arr1 = [1, [2, 3]];
						let arr2 = arr1.slice() / [...arr1] / [].concat(arr1)
						arr2[0] = 9;
						arr2[1][0] = 8;
						console.log(JSON.stringify(arr1))  //[1,[8,3]]
						console.log(JSON.stringify(arr2))  //[9,[8,3]]

	2，Object.assign()：只能实现一维对象的深拷贝
						let obj1 = {
							x: 'hello',
							y: {
								z: 'world'
							}
						}
						let obj2 = Object.assign({}, obj1);
						obj2.x = 'olleh'
						obj2.y.z = 'dlrow'
						console.log(JSON.stringify(obj1))  //{"x":"hello","y":{"z":"dlrow"}}
						console.log(JSON.stringify(obj2))  //{"x":"olleh","y":{"z":"dlrow"}}
	
	进行JSON.stringify()序列化的过程中，undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。
		 let obj = {
            a: 123,
            b: undefined,
            c(){
                console.log(11)
            },
            d:Symbol("haha"),
            e: 'cyp'
        }
        console.log(JSON.stringify(obj))  //{"a":123,"e":"cyp"}
		
        let arr = [12, undefined, function(){}, Symbol('ha'), 'cyp'];
        console.log(arr);  //(5) [12, undefined, ƒ, Symbol(ha), "cyp"]
        console.log(JSON.stringify(arr));  //[12,null,null,null,"cyp"]

	3，JSON.parse(JSON.stringify(obj))：可实现多维对象的深拷贝，但会忽略undefined、任意的函数、symbol 值
		let obj = {
            a: 123,
            g: {
                m: '999'
            },
            b: undefined,
            c(){
                console.log(11)
            },
            d:Symbol("haha"),
            e: 'cyp'
        }
        let obj2 = JSON.parse(JSON.stringify(obj));
        obj2.g.m = 888;
        console.log(obj)  //{a: 123, g: {m: "999"}, b: undefined, d: Symbol(haha), c: ƒ, …}
        console.log(obj2); //{"a":123,"g":{"m":888},"e":"cyp"}
	
	
	
  es6之扩展运算符(...)
	扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中
		-对象的扩展运算符
			let bar = { a: 1, b: 2 };
			let baz = { ...bar }; // { a: 1, b: 2 }
		  上述方法实际上等价于:
			let bar = { a: 1, b: 2 };
			let baz = Object.assign({}, bar); // { a: 1, b: 2 }
			
			Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
			Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)
	
			同样，对于扩展运算符而言，如果有同名属性，后面也会覆盖前面的
				let bar = {a: 1, b: 2};
				let baz = {...bar, ...{a:2, b: 4}};  // {a: 2, b: 4}
	
		-数组的扩展运算符
			-可以将数组转换为参数序列
				function add(x, y) {
				  return x + y;
				}

				const numbers = [4, 38];
				add(...numbers) // 42
			-可以复制数组		
				const arr1 = [1, 2];
				const arr2 = [...arr1];
	
		//个人觉得，扩展运算符只是把对象中所有可遍历属性给取了出来，至于后续的复制等动作是我们来做的，而不是扩展运算符来做的
		//rest参数是把参数序列转为数组，把所有苹果放到一个篮子里
		//扩展运算符是把数组转为参数序列，当然它也可应用于对象，但说它是rest参数的逆运算并不算错误。把篮子里的苹果给取出来
		
		const [first, ...rest] = [1, 2, 3, 4, 5]  //此处为rest参数和解构赋值的结合使用，下标为0的元素赋给first变量，剩下的参数序列赋值给rest参数
        console.log(first)  //1
        console.log(Array.isArray(rest)) //true
		
		等同于：
		const arr = [1, 2, 3, 4, 5]  
        const first = arr[0];
        const rest = arr.slice(1);
        console.log(rest)
	
	
	then方法返回一个Promise，而它的行为与then中的回调函数的返回值有关
		-如果then中的回调函数返回一个值，那么then返回的Promise将会成为成功状态，
		 并且将返回的值作为新Promise对象的成功状态的回调函数的参数值
		-如果then中的回调函数抛出一个错误，那么then返回的Promise将会成为失败状态，
		 并且将抛出的错误作为新Promise对象的失败状态的回调函数的参数值
		-如果then中的回调函数返回一个已经是成功状态的Promise，那么then返回的Promise
		 也会是成功状态，并且将那个Promise传出的参数值作为新Promise的成功状态的回调函数
		 的参数值
		-如果then中的回调函数返回一个已经是失败状态的Promise，那么then返回的Promise
		 也会是失败状态，并且将那个Promise传出的参数值作为新Promise的失败状态的回调函数
		 的参数值
		-如果then中的回调函数返回一个初始状态的Promise，那么then返回的Promise也会是
		 初始状态，并且它的终态与那个Promise的终态相同；同时，那个Promise变为终态时传出
		 的参数值作为新Promise变为终态时调用的回调函数的参数值
	
		一，
			let promise = new Promise((resolve, reject) => {
				setTimeout(() => {
					reject()
				}, 1000)
			})
			promise.then(() => {
				return 123
			}, (val) => {
				return 456
			}).then((val) => {
				console.log("succ"+val)
			}, (val) => {
				console.log("err"+val)
			})
		    // succ456
			
		二，
			let promise = new Promise((resolve, reject) => {
				setTimeout(() => {
					reject()
				}, 1000)
			})
			promise.then(() => {
			   return 123
			}, (val) => {
				throw new Error('faild')
			}).then((val) => {
				console.log("succ"+val)
			}, (val) => {
				console.log("err"+val)
			})
			// errError: faild
			
		三，
			let promise = new Promise((resolve, reject) => {
				setTimeout(() => {
					reject()
				}, 1000)
			})
			promise.then(() => {
			   return 123
			}, (val) => {
				return new Promise((resolve, reject) => {
					resolve('cyp')
				})
			}).then((val) => {
				console.log("succ"+val)
			}, (val) => {
				console.log("err"+val)
			})
			// succcyp
			
		四，
			let promise = new Promise((resolve, reject) => {
				setTimeout(() => {
					reject()
				}, 1000)
			})
			promise.then(() => {
			   return 123
			}, (val) => {
				return new Promise((resolve, reject) => {
					reject('cyp')
				})
			}).then((val) => {
				console.log("succ"+val)
			}, (val) => {
				console.log("err"+val)
			})
			// errcyp
			
		五，
			let promise = new Promise((resolve, reject) => {
				setTimeout(() => {
					reject()
				}, 1000)
			})
			promise.then(() => {
			   return 123
			}, (val) => {
				return new Promise((resolve, reject) => {
					setTimeout(() => {
						reject('cyp')
					}, 3000)
					
				})
			}).then((val) => {
				console.log("succ"+val)
			}, (val) => {
				console.log("err"+val)
			})
			// errcyp
	
	
	
单选框radio和复选框checkbox
<form>
	a1:  <input type="checkbox" name="apple" value="a1" />
	a2:  <input type="checkbox" name="apple" value="a2" />
	<input type="submit" value="提交">
</form>	

	全都打勾，点击提交时：xxx?apple=a1&apple=a2，由此可以看到name和value的作用体现在提交表单时，radio也是如此。
	单选框和复选框不写value，则提交表单时value值默认为on
	文本框写不写value都是不影响的，但必须要写name
	
	至于你想控制对号的显示，则需要操作的是 checked 属性
	
	他们的value和文本框的value是不一样的，文本框的value不光会出现url后的参数中，还会显示在界面中
		
	有一点要注意，不管是文本框，单选框，复选框都必须要有name属性，否则提交表单时不会添加到参数中



onchange  要在input内容发生改变，并且失去焦点时才会触发，可用于<input>, <select>, 和 <textarea>
oninput   在用户输入时触发，它是在元素值发生变化时立即触发，可用于<input>, <textarea>
onblur    在元素失去焦点时触发
onfocus   在元素获得焦点时触发

对于单选框和复选框来说，onchange和oninput事件的效果是一样的

例：
    <input @change="cc($event.target.value)" />
    <input @blur="cc($event.target.value)" />
    <input @input="cc($event.target.value)" />
	
	
	
下拉框
	<select  id="sel">
        <option value="aaa">A</option>
        <option>B</option>
        <option>C</option>
    </select>
	option没有value属性，那么下拉框的value就是<option>包裹的内容
	option有value属性，那么下拉框的value就是这个option value属性的值，<option>包裹的内容仅是展示用
	
	也就是说，有value就用value，没有就用包裹的内容
	
	
let {name: name2, age="123"} = {name: "jack"}
console.log(name)  // 空串
console.log(name2) //jack
console.log(age)  //默认值123   可以用es6中的参数默认值来为解构对象中没有对应属性的变量提供默认值
这种形式可以使用另一个变量来接收name的值，但注意此时就不能再使用name了，它会是一个空串
此处为解构赋值两个知识点：1，重命名  2，默认值



Polyfill 是一块代码（通常是 Web 上的 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。

比如说 polyfill 可以让 IE7 使用 Silverlight 插件来模拟 HTML Canvas 元素的功能，或模拟 CSS 实现 rem 单位的支持，或 text-shadow，或其他任何你想要的功能。


MVVM      M: model 模型   后端传来的数据   
		  V: view 视图    显示的页面
          VM: view model 视图模型
		  在MVVM的框架下view和model是不能直接通信的，需借助ViewModel进行通信
		  当model发生变化，ViewModel会监听到这种变化，然后通知view做相应的改变
		  当view发生变化，ViewModel会监听到这种变化，然后通知model做相应的改变
		  这实际上就实现了数据的双向绑定

浏览器的兼容性问题已经不再是前端的阻碍。前端的项目越来越大，项目的可维护性和扩展性、安全性等成了主要问题。  

Object.keys(obj) 方法会返回一个由给定对象自身可枚举属性组成的数组

Object.freeze()是ES5新增的特性，可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。防止对象被修改。

var obj = {
  foo: '不会变'
}
Object.freeze(obj)
change () {
  this.obj.foo = '改变'  // 会报错
}

change () {  // Object.freeze()冻结的是值，你仍然可以将变量的引用替换掉
  this.obj = {
	foo: '会改变'
  }
}

vue 1.0.18+对其提供了支持，对于data或vuex里使用freeze冻结了的对象，vue不会做getter和setter的转换。
如果你有一个巨大的数组或Object，并且确信数据不会修改，使用Object.freeze()可以让性能大幅提升。
new Vue({
    data: {
        // vue不会对list里的object做getter、setter绑定
        list: Object.freeze([
            { value: 1 },
            { value: 2 }
        ])
    },
    created () {
        // 界面不会有响应
        this.list[0].value = 100;

        // 下面两种做法，界面都会响应
        this.list = [
            { value: 100 },
            { value: 200 }
        ];
        this.list = Object.freeze([
            { value: 100 },
            { value: 200 }
        ]);
    }
})
对于纯展示的大数据，都可以使用Object.freeze提升性能


return str.charAt(0).toUpperCase() + str.slice(1)

沿着作用域链找，没找到，会报错
沿着原型链找，没找到，会是undefined



使用 逻辑运算符(或、与) 返回的值都是你运算时用的值，逻辑运算符 运算后的结果不会自动转换成 布尔值。
注：非运算 除外 (非运算会自动转换成布尔值)
平常在if() 语句中, 只不过if括号中的值 会自动转换为布尔值




Array.forEach  就是很普通的遍历，什么都不返回

Array.filter 对数组每一项运行给定函数，把对返回true的项添加到新数组里，最后返回新数组
Array.map 	 对数组每一项运行给定函数，把每次函数返回的结果添加到新数组里，最后返回新数组

Array.some   对数组每一项运行给定函数，有任一项返回true，则结果就为true
Array.every  对数组每一项运行给定函数，每一次该函数都返回true，则结果才为true

[1,2,3].filter((item, index. arr) => {...})  ((item, index) => {...})  (item => {...})    item 必需  index, arr 可选 

Array.find  对数组每一项运行给定函数，当函数返回true时，返回该项值，函数结束运行。没有返回true的项，则返回undefined
			对于空数组则不会执行
			[1,2,3].find((item, index, arr) { return item > 2 })   item 必需  index, arr 可选 
			
array.findIndex(function(currentValue, index, arr), thisValue)   只有currentValue是必需的，其它三个参数可选
返回数组中第一个符合条件的元素的位置，然后停止执行。没有找到则返回-1
[12,14,90].findIndex(currentValue => currentValue > 18)



| （竖线） 用于括号或大括号里，只能选一个 
[ ] （方括号） 可选可不选  
{}（大括号） 选一个 
<> 必选
[ ,...n ] 表示前面的项可重复 n 次。每一项由逗号分隔。 
[ ...n ] 表示前面的项可重复 n 次。每一项由空格分隔


表单元素的 disabled 的值为true，表示禁用该元素；值为false，表示启用该元素

浏览器宿主环境中有window全局对象；node宿主环境中有global全局对象


array.includes(searchElement, fromIndex) 方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false
	searchElement: 必需，查找的值
	fromIndex：可选，从哪里开始找  如果fromIndex 大于等于数组长度 ，则返回 false 。该数组不会被搜索
		var arr = ['a', 'b', 'c'];
 
		arr.includes('c', 3);   //false
		如果fromIndex小于 0，则整个数组都会被搜索。
		arr.includes('c', -3);   //true


localStorage和sessionStorage：
	localStorage 生命周期为永久，除非用户显式清除，否则信息一直存在。无论你重启多少次浏览器
	sessionStorage 生命周期为当前标签，当前标签关闭，信息也被清空
	
	localStorage.clear()  //清除全部信息
	localStorage.getItem() //获取指定key信息
	localStorage.setItem() //设置信息
    localStorage.removeItem() //移除指定key信息
	localStorage.length //获取信息个数
	常用方法(同样适用于sessionStorage)
	
localStorage.token = 'helloworld'    //也可以这样保存、读取
alert(localStorage.token)
	
Object.keys(obj)  返回一个表示给定对象的所有可枚举属性的字符串数组

	let person = {name:"张三",age:25,address:"深圳",getName:function(){}}
	Object.keys(person) // ["name", "age", "address","getName"]
	常用：
	Object.keys(person).map((key)=>{
	　　person[key] // 获取到属性对应的值，做一些处理

	}) 	

reduce 可以对数组进行遍历，但它会将每次遍历的结果传到下一轮回调中，最后一次回调的结果会被返回
arr.reduce(function(prev,cur,index,arr){
	...
}, init);
prev 表示上一次回调的返回值，或者初始值 init
cur 表示当前正在处理的数组元素
index 表示当前正在处理的数组元素的索引，若提供 init 值，则索引从0开始，否则从1开始
arr 表示原数组

	原始数组
	var arr = [3,9,4,3,6,0,9];
	
	1. 求数组项之和
		var sum = arr.reduce(function (prev, cur) {
			return prev + cur;
		},0);
		由于传入了初始值0，所以开始时prev的值为0，cur的值为数组第一项3，相加之后返回值为3作为下一轮回调的prev值，然后再继续与下一个数组项相加，以此类推，直至完成所有数组项的和并返回
		
	2. 求数组项最大值
		var max = arr.reduce((prev, cur) => {
			return Math.max(prev, cur)
		})
		由于未传入初始值，所以开始时prev的值为数组第一项3，cur的值为数组第二项9，取两值最大值后继续进入下一轮回调。
	
	3. 数组去重
		var newArr = arr.reduce(function (prev, cur) {
			prev.indexOf(cur) === -1 && prev.push(cur);
			return prev;
		},[]);
		初始化一个空数组
		在初始化数组里查找当前项，找不到，把当前项添加到初始化数组中
		然后初始化数组作为下一轮回调的prev值，继续查找
		最后返回初始化数组
		
$num指第num个匹配值
匹配值指正则中的pattern也就是括号部分	
	modulePath.replace(/^\.\/(.*)\.\w+$/, '$1')
	匹配到 ./app.js  使用第一个括号的匹配值进行替换  ./app.js  => app
	
String.fromCharCode()  将 Unicode 编码转为一个字符
	- 可接受一个指定的 Unicode 值，然后返回一个字符串
		var n = String.fromCharCode(65);  // A
		
stringObject.charCodeAt(index) 返回指定位置的字符的 Unicode 编码
	- 字符串中第一个字符的下标是 0。如果 index 是负数，或大于等于字符串的长度，则 charCodeAt() 返回 NaN
		var str="Hello world!";
		console.log(str.charCodeAt(1)); // 101


Unix时间戳(Unix timestamp)是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。Unix时间戳不仅被使用在Unix系统、类Unix系统中(比如Linux系统)，也在许多其他操作系统中被广泛采用

通过路由的meta标签对需要做校验的路由页面进行标记
	{
	  path: '/userInfo',
	  name: 'userInfo',
	  meta: {
		requireAuth: true,  // 该路由项需要权限校验
	  }
	  component: userInfo
	}, {
	  path: '/userList',
	  name: 'userList',    // 该路由项不需要权限校验    
	  component: userInfo
	}
之后，我们可以定义一个路由守卫，每次路由跳转，都来做一下权限校验
	router.beforeEach((to, from, next) => {
	  if (to.meta.requireAuth) {  // 判断该路由是否需要登录权限
		if (localStorage.token) {  // 获取当前的token是否存在
		  console.log("token存在");
		  next();
		} else {
		  console.log("token不存在");
		  next({
			path: '/login', // 将跳转的路由path作为参数，登录成功后跳转到该路由
			query: {redirect: to.fullPath}
		  })
		}
	  }
	  else { // 如果不需要权限校验，直接进入路由界面
		next();
	  }
	});

location 对象包含有关当前 URL 的信息，location 对象是 window 对象的一部分
	-hash 返回一个URL的锚部分
		console.log(location.hash) // #/documentation/index
	-host 返回一个URL的主机名和端口
		console.log(location.host) // localhost:9527
	-hostname 返回URL的主机名
		console.log(location.hostname) // localhost
	-href 返回完整的URL
		console.log(location.href) // http://localhost:9527/#/documentation/index
	-port 返回一个URL服务器使用的端口号
		console.log(location.port) // 9527
	-protocol 返回一个URL协议
		console.log(location.protocol) // http:
	-search 返回一个URL的主机名和端口
	
	-assign() 载入一个新的文档
	-replace() 用新的文档替换当前文档
	-reload() 刷新当前页面。该方法只有一个参数，当值为 true 时，将强制浏览器从服务器加载页面资源，当值为 false 或者未传参时，浏览器则可能从缓存中读取页面。
		location.reload()
		
CORS 的基本思想就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求响应是应该成功还是应该失败
当Http请求发起会带着以下请求头信息
	Origin:http://www.csdnblog.com
返回头也会夹带着类似如下信息
	Access-Control-Allow-Credentials:true 
	Access-Control-Allow-Origin:http://www.csdnblog.com
如果返回头中没有这个头部，或者有头部但是源信息不匹配。那么浏览器就会帮我们驳回这次请求，同源策略在这里发挥了作用

+new Date()  注意 + 号，可以返回时间戳


觉得好看的背景色 #2c343c

npm run build -- --config webpack.config.my.js  使用 npm run 后面想指定配置文件，需要加上 --

如果你想某个请求基于不同的 baseURL，可以在请求内部设置 baseURL，它会覆盖创建实例时的 baseURL
export function getInfo(token) {
  return fetch({
    baseURL: https://api2-xxxx.com
    url: '/user/info',
    method: 'get',
    params: { token }
  });
}

webpack4 的 style-loader   insertAt 改为 insert
postcss.config.js 必须得设置支持的浏览器才会自动添加前缀
	module.exports = {
	  plugins: {
		  'autoprefixer': {overrideBrowserslist: ['> 1%', 'last 2 versions']}
	  }
	}
	
	
vue脚手架如何使用 echarts 和 百度地图
1, 安装 echarts
	npm i echarts
2, 在 public 下的 index.html 中声明秘钥
	<script type="text/javascript" src="http://api.map.baidu.com/api?v=3.0&ak=秘钥"></script>
3, 引入 echarts 和 百度地图扩展
	import echarts from 'echarts'
	import 'echarts/extension/bmap/bmap'



//取消百度地图左下角图片标识  App.vue
.BMap_cpyCtrl {
  display: none;
}
.anchorBL {
  display: none;
}
	
type: scatter
emphasis: {
	label: {
		show: false   //并没卵用
	}
}

label: {
	...样式  //普通状态下的样式
}
itemStyle: {
	...样式   
}
emphasis: {   //它俩的高亮样式统一在这里写
	label: {
		...样式
	},
	itemStyle: { 
		...样式   
	}
}

mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick
mounted: function () {
  this.$nextTick(function () {
    // Code that will run only after the
    // entire view has been rendered
  })
}

 
 
以前的多页面站点是在服务端渲染的，输出到浏览器时已经有了完整的骨架（ html ），这样爬虫抓到时可以分析页面标题，内容等等，做 seo 容易，那时的技术栈是 jsp，php 等等。现在流行的前端框架在这方面是开了倒车，一个空的骨架，一个很大的 js，抓到浏览器以后才开始渲染完整的页面，爬虫就很为难了，因为它没法执行 js 啊，此外，白屏时间也是由于前端渲染带来的问题。于是又有了服务端渲染，让渲染这一步再回到服务端，在服务端模拟浏览器环境，给 react 和 vue 等框架一个可执行的上下文，就是为了提前得到完整的 html


[1,2,3].concat(4,5)    // [1,2,3,4,5] 	参数序列
[1,2,3].concat([4,5])	// [1,2,3,4,5]	数组
[1,2,3].concat({name: 'Jack'})  //[1,2,3,{name: 'Jack'}]  对象    都是返回一个新的数组

[1,2,3].concat(4,5,[6,7],{name: 'Jack'})  //[1, 2, 3, 4, 5, 6, 7, {name: 'Jack'}]  //也可以混着放在一起


let a = 'aaa';
var b = 'bbb';
console.log(window.a,window.b)  // undefined "bbb" 

let 声明的变量不会跟 var 一样作为 window 对象的属性


<el-input v-model="formDataCopy.ProvidentFundDetails[index].Base" maxlength="12" @input="changeNumber(index)" />
changeNumber(index) {
  this.formDataCopy.ProvidentFundDetails[index].Base = (this.formDataCopy.ProvidentFundDetails[index].Base.match(/^\d*(\.?\d{0,2})/g)[0]) || null
},
12位数字，小数点后最多两位

<el-input oninput="value=value.replace(/[^\d]/g,'')" maxlength="12" /> 只能输入数字
<el-input oninput="value=value.replace(/[^A-Za-z0-9\u4e00-\u9fa5']/g,'')" /> 只能输入英文、数字、汉字
<el-input oninput="value=value.replace(/[^A-Za-z0-9-\/']/g,'')" /> 只能输入英文、数字、/、-
<el-input oninput="value=value.replace(/[^\)\(\uff08\uff09']/g,'')" ></el-input> 只能输入半全角括号

当你发现v-model不好使的时候，不妨考虑一下 this.$set()方法，很可能是由于你的字段不是响应式的

以上会有一个bug：文本框中，如果输入法的键盘是中文状态， 在使用shift+任意按键组合件激活该输入框后，再次输入纯数字时会提示，该输入框为空的情况
解决办法为：<el-input v-model="form.assetsNumber" :readonly="isEdit" @input="form.assetsNumber=form.assetsNumber.replace(/[^A-Za-z0-9-\/']/g,'')" maxlength="30"></el-input>
如果是原生input可以用oninput，elementui还是用这么用吧。不知道怎么回事


debounce 函数防抖。当用户不断点击页面，短时间内频繁地触发点击事件，只有最后一次点击的函数会被执行。
只有在用户触发事件后的ns时间内，没有再触发事件，真正的监听函数才会执行，如果在这段时间内再次触发了事件，就需要重新计算这个ns
	_.debounce(func, [wait=0], [options={}])

	func (Function): 要防抖动的函数。

	[wait=0] (number): 需要延迟的毫秒数。

	[options={}] (Object): 选项对象。

	[options.leading=false] (boolean): 指定在延迟开始前调用，默认false。

	[options.maxWait] (number): 设置 func 允许被延迟的最大值。

	[options.trailing=true] (boolean): 指定在延迟结束后调用，默认true。
	
	import _ from 'lodash'
	testDebounce: _.debounce(function() {
	  console.log("debounce");
	}, 2000, {
	  leading: true,
	  trailing: false
	})
	

如果父组件想在子组件mounted之后作出相关操作，可以按照下面这种方式来写。

<!-- parent -->
<parent-component>
  <child-component @mounted="handleChildMounted"></child-component>
</parent-component>

// child
export default {
  mounted() {
    this.$emit('mounted')
  }
}

其实还有更简单的做法。
<!-- parent -->
<parent-component>
  <child-component @hook:mounted="handleChildMounted"></child-component>
</parent-component>

直接使用@hook就可以在父组件中监听子组件中钩子函数，不需要在子组件中额外地$emit一次。
同理，使用@hook还可以监听vue中其它的钩子函数，如@hook:created，@hook:destroyed等。


<el-tabs v-model="activeName">
	<el-tab-pane label="用户管理" name="first"></el-tab-pane>
	<el-tab-pane label="配置管理" name="second"></el-tab-pane>
	<el-tab-pane label="角色管理" name="third"></el-tab-pane>
	<el-tab-pane label="定时任务补偿" name="fourth"></el-tab-pane>
</el-tabs>
<component :is="isComponent" ></component>
<script>
import first from './first'
export default {
	components: {
		first,
		...
	},
    data() {
       return {
　　　　　　activeName: "first",
			componentsList: {
                first: first,//需要引入具体的组件
                second: "Second",
　　　　　　　　third: "Third",
　　　　　　　　four: "Four"
            }
       }
    },
    computed: {
        isComponent() {
              return this.componentsList[this.activeName];
        }
    }
}
</script>

call() apply() bind()
	相同点：都是用来改变函数内this的指向
	不同点：
		从调用来说：call和apply都是直接调用，bind会返回一个新的函数
		从传参来说：call和bind都是传参数序列，apply传的是一个数组
		

offsetTop offsetLeft
	只读属性。距离该元素最近的position不为static的祖先元素，如果没有则指向body。与这个祖先元素左侧，顶部的距离就是offsetLeft offseTop 
offsetWidth offsetHeight
	只读属性。指的是元素的content + padding + border 的长度（这是标准盒子模型下，IE盒子模型width就是offsetWidth）
	

2πr 是圆的周长
π 是圆周长和直径的比例   所以 c = 2r * π


在实际应用中，有的变量只有几种可能取值。如人的性别只有两种可能取值，星期只有七种可能取值。在 C 语言中对这样取值比较特殊的变量可以定义为枚举类型。所谓枚举是指将变量的值一一列举出来，变量只限于列举出来的值的范围内取值。 

使用Int16Array或Uint16Array来存储ArrayBuffer，那么ArrayBuffer的长度必须得是2的倍数。同理对于Int32Array或Uint32Array来说，ArrayBuffer的长度得是4的倍数


<son ref="son"></son>
父组件中：this.$refs.son.search('params')  父组件调用子组件，除了使用props。还可以通过ref调用子组件方法，给这个方法传参，子组件是可以接收到的

latest：最后版本，npm install的就是这个
beta：测试版本，一般内测使用，需要指定版本号install，例如3.1.0-beta.0
next: 先行版本，npm install foo@next安装，例如3.0.2-alpha.0


Vue事件总线（eventBus）$on()会多次触发
main.js
	const Bus = new Vue();
	new Vue({
		el: '#app',
		data: { Bus }
	})
a.vue
	this.$root.Bus.$emit('事件名', 参数1, 参数2);
b.vue
	this.$root.Bus.$on('事件名', 回调函数)
	
	Bus.$on实际是向Bus容器中添加一个事件监听器，当页面跳转时，原来的vue组件被注销，但是向Bus容器中添加的事件监听器并不会被移除。因此，当下次再进入这个vue组件时，又会执行Bus.$on，又会向Bus容器中添加
	一个重复的事件监听器，以此类推，导致Bus容器中有很多个一模一样的事件监听器，从而导致事件只被触发一次，但是回调函数被执行多次的现象。
	
	解决办法就是在beforeDestroy或destroy周期中将事件进行销毁
	beforeDestroy () {
      bus.$off('事件名')
    },
	
	当经过我实测，发现不止需要进行销毁，你的$on代码若放在created生命周期中，否则依然会被触发多次，解决办法为 created 改为 mounted 生命周期
	
	
	
Lint 是检验代码格式工具的一个统称，具体的工具有 Jslint 、 Eslint 等等。我们可以形象地将 Lint 看成是电商行业，而电商行业具体表现有淘宝（Eslint）、京东（Jslint）等
npm init 指令会在项目根目录下生成 package.json 文件
"scripts": {
    "test": "react-scripts test --env=jsdom",
    "lint": "eslint src",
    "lint:create": "eslint --init"
}
"lint:create": "eslint --init" 这个脚本是为了生成 .eslintrc.js 文件
"lint": "eslint src"  让 Lint 检验 src 目录下所有的 .js 文件

给 "lint": "eslint src --fix", 加上 --fix 参数，是让 Eslint 提供的自动修复基础错误。 --fix 只能修复基础的不影响代码逻辑的错误

"extends": "eslint:recommended",  官方提供的默认规则
eslint-config-airbnb 就是别人自定义的编码规范。"extends": "airbnb"，eslint-config 这个前缀可以省略不写

ESLint 附带有大量的规则，修改规则应遵循如下要求：

"off" 或 0 - 关闭规则
"warn" 或 1 - 开启规则，使用警告级别的错误：warn (不会导致程序退出)
"error" 或 2 - 开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出)

const apple = "apple";  // eslint-disable-line  跳过 eslint 校验

object-shorthand 设置该规则，表示对象属性要简写。
var foo = {x: x};    // 会报错
var bar = {a: function () {}};  // 会报错
var foo = {x};    // 不会报错
var bar = {a () {}};    // 不会报错

prefer-arrow-callback 要求回调函数使用箭头函数
// 回调函数，函数的参数是个函数，这个参数函数就是回调函数
funciton bar () {}      // 不是回调函数，不会报错
// setTimeout 的第一个参数就是回调函数，不用箭头函数会报错
setTimeout(() => {
    // .......
}, 1000)

no-param-reassign 禁止对函数的参数重新赋值
function bar ({ data = {} }) {
    data.num = 12;      // 会报错
}
/* 
虽然报错，又不想要将该校验关闭，如果代码中只有 data 这个属性有这种情形，
可以在 .eslintrc.js 中的 rules 属性中添加配置（可忽略 data 属性做此校验）：
'no-param-reassign': ['error', { 'props': true, 'ignorePropertyModificationsFor': ['data'] }],
'no-param-reassign': 0,  // 关闭该属性校验
*/

no-trailing-spaces 禁止行尾空格

no-shadow 禁止变量声明与外层作用域的变量同名
function sum (num) {
  let num = 2;    // 报错，因为 num 变量作为参数已经申明过了
}

常用的几个规则
"quotes": [1, "single"],            # 单引号
"quote-props":[2, "as-needed"],     # 双引号自动变单引号
"semi": [2, "never"],               # 一行结尾不要写分号
"comma-dangle": [1,"always-multiline"]  # 对象或数组多行写法时，最后一个值加逗号


css自定义属性
	--*来声明变量名，var(--*)来使用
	声明和使用必须放在{}代码块里
		body{
			--bg-color: lightblue;
			background-color: var(--bg-color);
		}
	在:root代码块里面声明的变量就是全局变量，并且局部变量会覆盖全局变量
		:root{
			--bg-color: red;
		}
		body{
			--bg-color: lightblue;
			background-color: var(--bg-color);
		}
		最后生效的是--bg-color: lightblue
	变量的缺省值
	完整的变量使用语法 var( [, ]? )，当变量没有定义的时候，会使用后面的值
		body{
			--1: red;
			color:var(--2, blue);
		}
		上面代码会在body的作用域里面查找--2变量，没有的话就会查找全局，都没有的话就会使用后面的值，所以最后生效的颜色就是blue
		变量名可以使用数字
	变量转换会带上空格
		:root{
			--1: lightblue;
			--文字颜色: white;
			--font-size: 30;
		}
		div{
			color: var(--文字颜色);
			font-size: var(--fong-size)px;
		}
		此时div里面的文字的大小是多少呢？是浏览器默认的大小，为什么不是咱们想象的30px呢，这是因为变量转换的时候末尾会带上空格，var(--fong-size)px会转换成30 px
		可以在声明变量的时候带上单位
			--fong-size: 30px;
		或者使用calc()计算属性
			font-size: calc(var(--fong-size) * 1px);
	js获取与赋值
		:root{
		 --bg-color: lightblue;
		}
		 // 获取
		getComputedStyle(document.documentElement).getPropertyValue('--bg-color')  // lightblue
		 // 赋值
		document.documentElement.style.setProperty('--bg-color', 'yellowgreen')
		
CSS object-position 属性
	一般与 object-fit一起使用，用来设置元素的位置，一般用于 img 和 video 标签
	默认值:	50% 50%
	继承:	是
	动画:	是
	版本:	CSS3
	JavaScript 语法: object.style.objectPosition="0 10%"
	语法
		object-position: position|initial|inherit;
		
		position 指定 image 或 video 在容器中的位置。第一个值为 x 坐标位置的值，第二个值为 y 坐标位置的值。表示的方式有：
			object-position: 50% 50%;
			object-position: right top;
			object-position: left bottom;
			object-position: 250px 125px;
		initial	设置为默认值
		inherit	从该元素的父元素继承属性
		
	object-fit 属性
		指定元素的内容应该如何去适应指定容器的高度与宽度。
		一般用于 img 和 video 标签，一般可以对这些元素进行保留原始比例的剪切、缩放或者直接进行拉伸等
		默认值:	fill
		继承:	无
		动画:	无
		版本:	CSS3
		JavaScript 语法: object.style.objectFit="cover"
		语法
			object-fit: fill|contain|cover|scale-down|none|initial|inherit;
			
			fill	默认，不保证保持原有的比例，内容拉伸填充整个内容容器
			contain	保持原有尺寸比例。内容被缩放，可能不会填充整个内容容器
			cover	保持原有尺寸比例。但部分内容可能被剪切，但内容一定会填充整个内容容器
			none	保留原有元素内容的长度和宽度，也就是说内容不会被重置，可能不会填充整个内容容器
			scale-down	保持原有尺寸比例。内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些
			initial	设置为默认值
			inherit	从该元素的父元素继承属性
			
			具体请参考css下的objectFit.html






	var name = 'jack', age = 27
    let obj = {
      objName: 'selina',
      objAge: this.age,    //this  指向 window
      func(){
        console.log(this.objName +'   '+ this.age)  //this 指向 obj
      }
    }

    var apple = 'green'
    function getApple(){
      console.log(this.apple)   //this  指向 window
    }
    console.log(obj.objAge)  //27
    obj.func()   //selina undefined
    getApple()   // green
	
	注：let声明的变量不会成为window对象的属性，所以上面不要用let声明
	
	call()、apply()、bind() 都是用来重定义 this 这个对象的
		let obj = {
		  name: 'selina',
		  age: 11,
		  func(sex, addr){
			console.log(this.name +'   '+ this.age +'   '+ sex +'    '+ addr)
		  }
		}

		let obj2 = {
		  name: 'Jack',
		  age: 22
		}
		obj.func.call(obj2, 'man', 'new York')
		obj.func.apply(obj2, ['woman', 'china'])
		obj.func.bind(obj2, 'unknow', 'hongkong')()
	关于三者的区别主要从两个方面来说：
		1，执行时机
			call和apply都是立即执行
			bind会返回一个函数，必须手动调用
		2，传参
			他们的第一个参数都是要指向的this对象
			从第二个参数开始：
				call和bind 传的n个参数都是用逗号进行分隔的
				apply的第二个参数必须是一个数组，传给函数的n个参数必须放在数组里
                
                
                
property 和 attribute

	如下HTML code：
		<div id="" class=""></div>
			标签指的是 div，标签上有附加信息我们称之为 HTML 属性(attribute)，如 id，class。合起来，我们统称为HTML元素，
			而一个HTML文档就是多个HTML元素构成的。
			
	而HTML DOM是 HTML 的标准对象模型，DOM(Document Object Model)，直译就是文档对象模型
	HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法。
	而DOM对象上的属性我们称之为property。
	
	编写HTML源代码时，可以在HTML元素上定义属性(attribute) 。 然后，一旦浏览器解析了您的代码，就会创建一个对应的DOM节点。 该节点是一个对象，因此具有属性 (property)。
	
	<input id="inputID" type="text" value="name">
	input元素有两个属性(attribute)，type和value
	浏览器解析这段代码后，将创建一个HTMLInputElement对象，该对象将包含许多属性。例如：childNodes，classList，className...，这些属性叫做property
	通过 domObj.attibutes.attribute 可以访问html元素上定义的attribute

	因为是根据HTML元素创建的DOM节点对象，所以会有许多与attribute相关的property，但这并不是一对一的关系

	id property 是映射的 id attribute。获取id的property就是获取attribute值，设置也是一样。
		var inputDom = document.querySelector('#inputId')
		console.log(inputDom.getAttribute('id'))
		console.log(inputDom.id)
		// "inputId"
		// "inputId"

		inputDom.setAttribute('id','inputId2')     //设置attribute
		console.log(inputDom.getAttribute('id'))
		console.log(inputDom.id)
		// "inputId2"
		// "inputId2"

		inputDom.id = 'inputId'				//设置property
		console.log(inputDom.getAttribute('id'))
		console.log(inputDom.id)
		// "inputId"
		// "inputId"
		
	DOM节点对象上的type property是映射 type attribute
	type不是纯粹的映射属性，因为它的值只能为 已知值 （例如:text，submit，button，checkbox等等  设置type为未知值 时 property始终为text。
		var inputDom = document.querySelector('#inputId')
		console.log(inputDom.getAttribute('type'))
		console.log(inputDom.type)
		// text
		// text

		inputDom.setAttribute('type','007')        //设置attribute 为 未知值
		console.log(inputDom.getAttribute('type'))
		console.log(inputDom.type)
		// 007
		// text

		inputDom.type = '008'					//设置property  为 未知值
		console.log(inputDom.getAttribute('type'))
		console.log(inputDom.type)
		// 008
		// text

	value property 不是完全映射value attribute
		var inputDom = document.querySelector('#inputId')
		console.log(inputDom.getAttribute('value'))
		console.log(inputDom.value)
		// name
		// name

		inputDom.setAttribute('value','007')     //改变attribute值时，property也会跟着变
		console.log(inputDom.getAttribute('value'))
		console.log(inputDom.value)
		// 007
		// 007

		inputDom.value = '008'					//改变property值时，attribute不会跟着变
		console.log(inputDom.getAttribute('value'))
		console.log(inputDom.value)
		// 007
		// 008
	总结
		HTML属性 (attribute)和 DOM属性(property)，是相互关联的。多数情况attribute仅用作初始化DOM节点对象使用，而property更多用于页面交互，很多框架都是在与元素和指令的 property和事件打交道。
		
		
		
		
需求说明：手动上传特定格式的文件，展示所选文件名称，且能实现覆盖上传。
		1， 解决手动上传问题
			只需要在Upload组件添加 属性  :auto-upload="false" ，然后调用  this.$refs.upload.submit(); 方法即可。
		2，解决特定格式文件问题	
			Upload组件添加 属性 accept=".xxx"
		3，最麻烦的是上传限制问题	
			首先想到 Upload组件添加属性 :limit="1"，但是这样，无论怎么选择文件，页面上展示的始终是第一次选择的文件
			然后想通过on-change方法，改变file-list里选择的文件列表，只保留最后一项
				handleChange(file, fileList) {
					if (fileList.length > 0) {
						this.fileList = [fileList[fileList.length - 1]]
					}
				},
			但是有一个样式问题，用户选择第二个文件后，从第一个文件到第二个文件，有动态切换的效果
			可以通过css去掉这部分动画
				<style lang="scss" scoped>
					.upload-demo {
					  display: flex;
					}
					/deep/ .el-list-enter-active,
					/deep/ .el-list-leave-active {
					  transition: none;
					}
				 
					/deep/ .el-list-enter,
					/deep/ .el-list-leave-active {
					  opacity: 0;
					}
					/deep/ .el-upload-list {
					  height: 40px;
					}
				</style>
			
			
			
			
<el-form :model="orderData">
    <el-form-item prop="passengerInfo[0].ticketNos[0].ticketNo"></el-form-item>
</el-form>		

orderData: {
  passengerInfo: [{
    ticketNos: [{
      ticketNo: 'fddfg'
    }]
  }]
}	

Error: please transfer a valid prop path to form item!

el-form-item上的属性prop字段，必须是其父级组件el-form中绑定model字段中的一个直接子属性。在这个示例中必须保证不管何时orderData.passengerInfo[0].ticketNos[0].ticketNo可以访问到，访问链路中不能出错。

<el-form :model="orderData">
    <el-form-item prop="'passengerInfo.'+firstIndex+'.ticketNos.'+firstIndex+'.ticketNo'""></el-form-item>
</el-form>






开发要搞清楚什么是并发，并行，串行，同步，异步
	1.并发编程又叫多线程编程
		并发当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间 段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。.这种方式我们称之为并发
	2.并行
		当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，
		可以同时进行，这种方式我们称之为并行(Parallel)。	
	
		并发和并行 
			并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可以同时执行。
			
	3.串行、并行		
		  并行和串行指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行，异步是多个任务并行的前提条件	
			
	4.同步、异步		
		指的是能否开启新的线程。同步不能开启新的线程，异步可以。
        异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。
        异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理	
			
	5.多线程：多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码。多线程可以实现线程间的切换执行。		
			
			
			
			
			
类型化数组是javascript操作(内存)二进制数据的一个接口。

类型化数组是建立在ArrayBuffer对象的基础上的。它的作用是，分配一段可以存放数据的连续内存区域。

var buf = new ArrayBuffer(32); //生成一段32字节的内存区域，即变量buf在内存中占了32字节大小

ArrayBuffer对象的byteLength属性，返回所分配的内存区域的字节长度。

buf.byteLength //32

如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。
if (buffer.byteLength === n) {
  // 成功
} else {
  // 失败
}

ArrayBuffer作为内存区域，可以存放多种类型的数据。不同数据有不同的存储方式，这就叫做“视图”。目前，JavaScript提供以下类型的视图
Int8Array：8位有符号整数，长度1个字节。
Uint8Array：8位无符号整数，长度1个字节。
Int16Array：16位有符号整数，长度2个字节。
Uint16Array：16位无符号整数，长度2个字节。
Int32Array：32位有符号整数，长度4个字节。
Uint32Array：32位无符号整数，长度4个字节。
Float32Array：32位浮点数，长度4个字节。
Float64Array：64位浮点数，长度8个字节。

每一种视图都有一个BYTES_PER_ELEMENT常数，表示这种数据类型占据的字节数
int8Array.BYTES_PER_ELEMENT // 1
Int16Array.BYTES_PER_ELEMENT // 2

生成视图有两种方法:
1,在ArrayBuffer对象上生成
// 创建一个8字节的ArrayBuffer
var b = new ArrayBuffer(8);

// 创建一个指向b的Int32视图，开始于字节0，直到缓冲区的末尾
var v1 = new Int32Array(b);

// 创建一个指向b的Uint8视图，开始于字节2，直到缓冲区的末尾
var v2 = new Uint8Array(b, 2);

// 创建一个指向b的Int16视图，开始于字节2，长度为2
var v3 = new Int16Array(b, 2, 2);

2,直接生成
var v4 = new Int32Array(3); //创建一个数组长度为3的类型化数组
v4.length // 3;
v4.byteLength //12 变量v4占12字节的内存大小 ；一个32位数字占4个字节，该数组共有3个元素所以是4*3等于12			
			
			
			
			
			
Blob（Binary Large Object）对象代表了一段二进制数据，提供了一系列操作接口。（以二进制形式保存的较大的对象）比如通过new Blob()创建的对象就是Blob对象.又比如,在XMLHttpRequest里,如果指定responseType为blob,那么得到的返回值也是一个blob对象			
	1,生成Blob对象有两种方法：一种是使用Blob构造函数，另一种是对已有的Blob对象使用slice()方法切出一段		
		Blob构造函数	
			var blob = new Blob(data, type) 
			Blob构造函数接受两个参数
				参数data是一组数据，所以必须是数组，即使只有一个字符串也必须用数组装起来
				参数type是Blob对象的配置属性，目前只有一个type也就是mime需要设置
					‘text/csv,charset=UTF-8’ 设置为csv格式，并设置编码为UTF-8
					‘text/html’ 设置成html格式
					
			var blob = new Blob(['我是Blob'],{type: 'text/html'}); 
		属性	
			blob.size   //Blob大小（以字节为单位） 
			blob.type   //Blob的MIME类型，如果是未知，则是“ ”（空字符串）
	2，slice()
		slice()返回一个新的Blob对象，包含了源Blob对象中指定范围内的数据
			blob.slice( start, end, contentType)
			start 可选，开始索引,可以为负数,语法类似于数组的slice方法.默认值为0.
			end 可选，结束索引,可以为负数,语法类似于数组的slice方法.默认值为最后一个索引.
			contentType可选 ，新的Blob对象的MIME类型,这个值将会成为新的Blob对象的type属性的值,默认为一个空字符串
			
	3,使用Blob最简单的方法就是创建一个URL来指向Blob		
		var data= 'Hello world!'; 
		var blob = new Blob([data], { 
		  type: 'text/html,charset=UTF-8' 

		}); 
		window.URL = window.URL || window.webkitURL;  
		document.createElement("a").href = URL.createObjectURL(blob); 	
			
		使用URL.createObjectURL()函数可以创建一个Blob URL，参数blob是用来创建URL的File对象或者Blob对象，返回值格式是：blob://URL	
			
		注意：在每次调用 createObjectURL() 方法时，都会创建一个新的 URL 对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用 URL.revokeObjectURL() 方法传入创建的URL为参数，用来释放它。浏览器会在文档退出的时候自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们。	
	
	当数据中包含汉字时，导出的文件可能会出现乱码，不过我们可以这样解决
		var data = "\ufeff" + "汉字"; 
		
		
		
offsetTop, offsetLeft：只读属性，距离offsetParent的偏移距离。offsetParent指的是距该元素最近的position不为static的祖先元素		
offsetWidth, offsetHeight：只读属性，  width + padding + border
scrollWidth, scrollHeight: 只读属性, 在内容没有溢出的情况下等于 content + padding
									在内容溢出的情况下等于元素中内容的宽度加上内边距  也就是  width - 17px滚动条的宽度  + padding 
scrollTop, scrollLeft 滚动条 滚动的距离		
		
window.innerWidth, window.innerHeight：window对象的只读属性,声明了窗口的文档显示区的高度和宽度，以像素(px)为计量单位。 
(注意：这里的宽度和高度不包括浏览器的标签栏、搜索栏等还有操作系统的任务栏等高度
屏幕分辨率为：1920x1080		
alert(window.innerWidth); 		//窗口的宽度 1920px
alert(window.innerHeight); 　　//窗口的高度 950px
innerWidth因为浏览器两旁没有遮挡物,所以完美的得到了屏幕的宽度1920,而innerHeight因为浏览器上面有工具栏,显示屏又有任务栏,所以被挤掉了130px		
		
clientWidth, clientHeight: 	content + padding   (注：我这里所指的content指的是width-滚动条的内容宽度，如果没有滚动条，那么content等于width)     
在chrome里滚动条的宽度为16.8，也就是 clientWidth = 四舍五入(width - 16.8) + padding 
		
Element.getBoundingClientRect()：只读，返回浮点值，常用于确定元素相对于视口的位置。该方法会返回一个DOMRect对象，包含left, top, width, height, bottom, right六个属性
top，left 和css中的理解一样，元素上边界距窗口顶部的距离
right，bottom有点不一样，它是元素下边界距窗口顶部的距离、元素右边界距窗口左侧的距离

width和height  和offsetWidth, offsetHeight一样，都是 width + padding + border



/* ::after表示法是在CSS 3中引入的，:after 是表示法是在css2中引入的  
 css3为了区分伪类和伪元素，伪元素采用双冒号写法 例如 ::before ::after。伪类采用单冒号写法 例如 :hover :link :focus :not()
element:after  { style properties }  /* CSS2 语法 */
element::after { style properties }  /* CSS3 语法 */


::before 是某标签前的兄弟元素
::after 是某标签后的兄弟元素
	p::before {
	  content: '我是在p标签前的兄弟元素'
	}
	p::after {
	  content: '我是在p标签前的兄弟元素'
	}
	
	
	
vue-cli 项目下生成二维码	
	使用 qrcodejs2
		npm install --save qrcodejs2
	然后在需要生成的相关页面
		<template>
		  <div>
		   <div id="qrcode"></div>
		  </div>
		</template>
	
		import QRCode from 'qrcodejs2' 
 
		methods:{
			// 动态生成二维码
		    qrcode () {  
				let qrcode = new QRCode('qrcode', {
					width: 200, // 设置宽度，单位像素
					height: 200, // 设置高度，单位像素
					text: 'https://www.baidu.com'   // 设置二维码内容或跳转地址
				})
			}  
		},
		created () {
			this.$nextTick(() => {
				this.qrcode()
			})
		}

	
VUE使用 print-js 打印指定区域页面	
	npm安装
		npm install print-js --save
	然后在相关页面
		<template>
		  <div>
			<el-button type="primary" @click="print"></el-button>
			<div id="print-div">
			  <p class="red">世上本没有路，走的人多了，便有了路 ---- 鲁迅</p>
			  <p class="green">世上本没有路，走的人多了，便有了路 ---- 鲁迅</p>
			  <p style="display:none">世上本没有路，走的人多了，便有了路 ---- 鲁迅</p>  //不需要打印内容可以通过css，js两种方法控制
			  <p class="hello">世上本没有路，走的人多了，便有了路 ---- 鲁迅</p>
			</div>
		  </div>
		</template>
	
		import print from "print-js";
		
		methods: {
			print() {
			  const style = `   //可以通过css控制打印内容样式，不过需写在 @media print{...}中
				@media print {
				  .red{
					color:#f00
				  } 
				  .green{
					color:green
				}
			  `;
			  let hello = document.querySelector('#print-div .hello')   //不需要打印内容可以通过css，js两种方法控制
			  hello.style.display = 'none'
			  
			  printJS({
				printable: "print-div", // 标签元素id
				type: "html",
				header: "这是标题",
				style: style,
			  });
			},
		  },
	


path.join()和path.resolve()的区别
	path.join() 方法会将所有给定的 path 片段连接到一起（使用平台特定的分隔符作为定界符  Unix系统是/，Windows系统是\ ），然后规范化生成的路径。
	长度为零的 path 片段会被忽略。 如果连接后的路径字符串为长度为零的字符串，则返回 '.'，表示当前工作目录。
		__dirname返回当前文件所在的绝对路径  //f:\code\demo
		path.join(__dirname, './foo/bar');   //f:\code\demo\foo\bar
		path.join('目录1', '目录2'); // 目录1\目录2
		path.join('/目录1', '\\目录2', '目录3/目录4', '目录5', '..');  //  \目录1\目录2\目录3\目录4   \需要转义，所以是\\
		path.join('foo', 'bar', '..', '..') // .. 表示上一级目录，所以连接后的路径字符串长度为0，返回 '.'
		path.join('目录1', {}, '目录2');  //抛出 'TypeError: Path must be a string. Received {}'

	path.resolve() 方法会将路径或路径片段的序列解析为绝对路径
		path.resolve('/目录1/目录2', './目录3');  //f:\目录1\目录2\目录3
		path.resolve('/目录1/目录2', '/目录3/目录4/')  //f:\目录3\目录4
		path.resolve('目录1', '目录2/目录3/', '../目录4/文件.gif')  //f:\code\demo\目录1\目录2\目录4\文件.gif
		
		生成的路径会被规范化，并且尾部的斜杠会被删除（除非路径被解析为根目录）。
			path.resolve('a','b/')  //f:\code\demo\a\b
		如果没有传入 path 片段，则 path.resolve() 会返回当前工作目录的绝对路径。
			path.resolve()  //f:\code\demo

	path.join() 与 path.resolve()的区别：
		join 只是单纯的拼接路径
		resolve 不光会拼接路径，最后一定会返回一个绝对路径




一、webpack的打包原理

	识别入口文件
	通过逐层识别模块依赖(Commonjs、amd或者es6的import，webpack都会对其进行分析，来获取代码的依赖)
	webpack做的就是分析代码，转换代码，编译代码，输出代码
	最终形成打包后的代码
二、什么是loader

	loader是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中
	处理一个文件可以使用多个loader，loader的执行顺序和配置中的顺序是相反的，即最后一个loader最先执行，第一个loader最后执行
	第一个执行的loader接收源文件内容作为参数，其它loader接收前一个执行的loader的返回值作为参数，最后执行的loader会返回此模块的JavaScript源码

三、什么是plugin

	在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的API改变输出结果。

四、loader和plugin的区别

	对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程
	plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务








新建一个目录，执行 npm init ，安装webpack webpack-cli
	npm i webpack webpack-cli -D
该目录下新建src目录，在src下新建index.js。在src下新建dist目录，里面写个index.html引入bundle.js
一对一:
	新建webpack.config.js:
		const path = require('path');
		module.exports = {
			entry: './src/index.js',
			output: {
				path: path.resolve(__dirname, 'dist'),
				filename: 'bundle.js'
			}
		}
	执行npx webpack 即可打包出bundle.js

多对一打包(打包到一起)：
	在src下新增index2.js。更改entry: ['./src/index.js', './src/index2.js']   entry支持数组类型，按照数组中元素顺序由前往后打包
	执行npx webpack 即可打包出bundle.js

多对多(多入口多出口):
	修改webpack.config.js：
		module.exports = {
			entry: {
				index: './src/index.js',
				index2: './src/index2.js'
			},
			output: {
				path: path.resolve(__dirname, 'dist'),
				filename: '[name]-bundle.js'      //[name] 表示入口中的key
			}
		}
	执行npx webpack 即可打包出 index-bundle.js 和 index2-bundle.js

如何自动生成html，并且引入js呢
	安装html-webpack-plugin，因为开发时需要，所以加 -D
	npm i html-webpack-plugin -D
	安装成功后，在webpack.config.js里引入
		const HtmlWebpackPlugin = require('html-webpack-plugin');   
		module.exports = {
			...,
			 plugins:[
				new HtmlWebpackPlugin()
			]
		}
	执行npx webpack 会发现自动生成了index.html，并且也都引入index-bundle.js, index2-bundle.js

	使用模板 index.html
		在src下写一个模板 html 文件
			plugins:[
				new HtmlWebpackPlugin({
					template: './src/index.html' //模板地址
				})
			]
		自动配置页面title，把 html title改为 <title><%= htmlWebpackPlugin.options.title%></title>
			

	解决src引入的缓存问题
		new HtmlWebpackPlugin({
            hash: true, //在引入的js后面添加hash值，解决缓存问题
            title: 'I love China',
            template: './src/index.html'
		}
		
	压缩输出
		new HtmlWebpackPlugin({
            hash: true,
            title: 'I love China',
            template: './src/index.html',
			minify:{
                collapseWhitespace:true //折叠空白区域 也就是压缩代码
            }
		}
	
	多个HTML模板区分输出配置
		plugins: [
			new HtmlWebpackPlugin({
				chunks:['index'],
				hash: true,
				title: 'I love China',
				template: './src/index.html',
				minify:{
					collapseWhitespace:true //折叠空白区域 也就是压缩代码
				}
			},
			new HtmlWebpackPlugin({
				chunks:['index2'],  //引入js，index2为entry中的key
				hash: true,
				title: 'I love China',
				template: './src/index2.html',
				minify:{
					collapseWhitespace:true //折叠空白区域 也就是压缩代码
				}
			}
		]
	执行 npx webpack 会生成两个html文件，并且各自引入各自的js文件
	
	
	
	
参数默认值可以与解构赋值的默认值，结合起来使用。

function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property 'x' of undefined
上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。

function foo({x, y = 5} = {}) {
  console.log(x, y);
}

foo() // undefined 5
	
有一点注意：foo传的值不是个对象，也可以使用解构默认值，foo(2) //undefined 5
	
	
	
	
	
Object.entries() 方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）。
通俗点就是 Object.entries() 可以把一个对象的键值以数组的形式遍历出来，结果和 for...in 一致，但不会遍历原型属性。
	示例1 -- 传入对象
		const obj = { foo: 'bar', baz: 'abc' }; 
		console.log(Object.entries(obj));  // [['foo', 'bar'], ['baz', 'abc']]
	示例2.1 -- 数组
		const arr = [1, 2, 3]; 
		console.log(Object.entries(arr));  // [['0', 1], ['1', '2'], ['2', '3']]
	示例2.2 -- 数组（数组中包含对象）
		const arr1 = [{ a: 1 }, 2, 3]; 
		console.log(Object.entries(arr1));  // [['0', { a: 1 }], ['1', '2'], ['2', '3']]
	示例2.3 -- 数组（数组中的值全部为对象）
		const arr2 = [{ a: 1 }, { b: 2 }, { c: 3 }]; 
		console.log(Object.entries(arr2));  // [['0', { a: 1 }], ['1', { b: 2 }], ['2', { c: 3 }]]
	示例3 -- 字符串	
		const str = '123'; 
		console.log(Object.entries(str));  // [['0', '1'], ['1', '2'], ['2', '3']]
	示例4 -- 数字、浮点数	
		const num = 123;
		console.log(Object.entries(num));  // []

		const float1 = 12.3;
		console.log(Object.entries(float1));  // []
	示例5 -- 将 Object 转化为 Map	
		new Map() 构造函数接受一个可迭代的 entries 。 借助 Object.entries 方法你可以很容易的将 Object 转换为 Map:
		const obj2 = { foo: 'bar', baz: 'abc' }; 
		console.log(Object.entries(obj2));  // [['foo', 'bar'], ['baz', 'abc']]
		
		const map = new Map(Object.entries(obj2)); 
		console.log(map); // Map {'foo' => 'bar', 'baz' => 'abc'}
		
		
		
ES6解构-对象解构
	1,解构用于变量声明
		let node = {
			name: 'mike',
			age: 25
		};
		let {name, age} = node;
		console.log(name, age); // 'jack' 25
		对象的解构是利用对象的属性名，所以无关顺序,依然可以正确输出
			let {age, name} = node;
			console.log(name, age); // 'jack' 25
		但是属性名如果对应不上，则会输出undefined
			let {name, age2} = node;
			console.log(name, age2); // 'jack' undefined
			
	2,解构用于变量赋值
		let node = {
		  name: 'Jack',
		  age: 25
		}
		let name = '', age = '';
		({name, age} = node)   // 解构赋值的语法要求，一定要用一对小括号()包裹整个解构赋值表达式。
		console.log(age, name) //25 'Jack'
	
	3,给解构的变量设置默认值
		let node = {
		  name: 'Jack',
		  age: 25
		}
		let {name, age, gender='male'} = node;
		console.log(name, age, gender)  //Jack 25 male
		当对象中没有对应的属性时，就会使用 = 后面的默认值
	
	4,别名
		let node = {
		  name: 'Jack',
		  age: 25
		}
		let {name:localname, age, gender:localgender='male'} = node;
		console.log(localname, age, localgender)  //Jack 25 male
		需注意，定义了别名，就不能再使用原来的名字了，否则会报错，例如：
		console.log(name, age, localgender); // ReferenceError: name is not defined
		
	5,嵌套对象的解构
		let node = {
		  personalInfo: {
			  basicInfo: {
				  name: 'mike',
				  age: 25
			  }
		  },
		  level: 3
		};
		let { personalInfo: { basicInfo } } = node;
		console.log(basicInfo);   //{ name: 'mike', age: 25 }
		上面代码倒数第二行，我们初始化的变量为basicInfo，而不是personalInfo，这一点要特别注意。personalInfo只是用来指明basicInfo的父节点。
		嵌套对象解构的语法就是：从原对象的最外层变量定位，一直到需要取值的那一层，每层之间用冒号:隔开，变量在冒号的右边
		let node = {
		  personalInfo: {
			  basicInfo: {
				  name: {
					  firstName: 'mike',
					  lastName: 'deep'
				  },
				  age: 25
			  }
		  },
		  level: 3
		};
		let { personalInfo: {basicInfo: {name}} } = node;
		console.log(name); //{ firstName: 'mike', lastName: 'deep' }
	
ES6解构-数组解构
	数组的解构是利用坐标的一一对应
	1,解构用于变量声明
		let color = ['red', 'green', 'blue'];
		let [firstColor, secondColor] = color;
		console.log(firstColor,secondColor);  //red green
		如果只是想要中间位置或最后位置的数据，那么前面位置上的每一个元素留空，用逗号相隔就行了
			let color = ['red', 'green', 'blue'];
			let [, , thirdColor] = color;
			console.log(thirdColor);  //blue
	
	2,解构用于变量赋值
		let color = ['red', 'green', 'blue'];
		let firstColor = '', secondColor = '';
		[firstColor, secondColor] = color;
		console.log(firstColor,secondColor);  //red green
		数组解构赋值语法和对象解构赋值语法很像，只是不需要再用 () 包裹
	
	3,嵌套数组（多维数组）的解构
		let color = ['red', ['white', 'black'],'green', 'blue'];
		let [firstColor, [childColor]] = color;
		console.log(firstColor,childColor);  //red white
		[childColor] 使用[]包裹，那就说明我们解构出的是 'white' 这个值了
	
	4,不定元素（剩余元素）
		函数有不定参数，在数组解构这里有个类似的概念：不定元素（或者叫剩余元素）。它就是用...展开运算符把数组的多个元素一起赋值给一个变量
			let color = ['red', 'green', 'blue'];
			let [firstColor, ...secondColor] = color;
			console.log(firstColor,secondColor);  //red [ 'green', 'blue' ]
		需要注意的是不定元素变量（剩余元素变量）必须是解构的最后一个变量，其后面不能再有别的变量，否则会抛出语法错误
			let color = ['red', 'green', 'blue'];
			let [firstColor, ...secondColor, thirdColor] = color;
			console.log(firstColor, secondColor, thirdColor);  //SyntaxError: Rest element must be last element
		既然剩余元素可以是数组的最后几个元素，那它当然也可以是数组的全部元素。我们可以利用这点来实现数组的copy：
			let color = ['red', 'green', 'blue'];
			let [...copiedColor] = color;
			console.log(copiedColor);  // [ 'red', 'green', 'blue' ]
			console.log(color.toString() === copiedColor.toString());  // true
			console.log(color == copiedColor);  // false
		剩余元素变量只是把数组元素copy到另一个数组，所以它们包含的元素相等，但是这2个数组是没有关系的，是不相等的
	
	5,对象和数组的混合解构
		let node = {
		  personalInfo: {
			  basicInfo: {
				  name: {
					  firstName: 'mike',
					  lastName: 'deep'
				  },
			  }
		  },
		  levelRange: [1, 3]
		};
		let {
		  personalInfo: {basicInfo: {name}},
		  levelRange: [lowLevel]
		} = node;

		console.log(name); // { firstName: 'mike', lastName: 'deep' }
		console.log(lowLevel); // 1
		其实混合解构和单独的对象解构和数组解构是一样的，对象的地方就用对象解构的语法，数组的地方就用数组解构的语法就对了
	
	
	
$on和$emit
	main.js
		export let bus = new Vue()
	parent.vue
		import { bus } from './../main.js'
		create(){
			bus.$on('edit', (val) => {
				console.log(val)
			})
		}
	child.vue
		import { bus } from './../main.js'
		methods: {
			save(){
				bus.$emit('edit', '自定义参数')
			}
		}
	
	
	


ES6-class
	class 是 ES6 的新特性，可以用来定义一个类，实际上，class 只是一种语法糖，它是构造函数的另一种写法。（什么是语法糖？是一种为避免编码出错和提高效率编码而生的语法层面的优雅解决方案，简单说就是，一种便携写法。）
		class Person {

		}
		typeof Person // "function"
		Person.prototype.constructor === Person // true

	1，使用
		用法和使用构造函数一样，通过 new 来生成对象实例
		class Person {

		}
		let jon = new Person()
	2，constructor
		每个类都必须要有一个 constructor，如果没有显示声明，js 引擎会自动给它添加一个空的构造函数
		class Person {

		}
		// 等同于
		class Person {
		  constructor () {

		  }
		}
	3，属性和方法
		定义于 constructor 内的属性和方法，即定义在 this 上，属于实例属性和方法，否则属于原型属性和方法。
			class Person {
			  constructor (name) {
				this.name = name
			  }
			  say () {
				console.log('hello')
			  }
			}

			let jon = new Person()

			console.log(jon.hasOwnProperty('name')) // true
			console.log(jon.hasOwnProperty('say')) // false
	4，属性表达式
		let methodName = 'say'
		class Person {
		  constructor (name) {
			this.name = name
		  }

		  [methodName] () {
			console.log('hello')
		  }
		}

		new Person().say()  // hello	
	5，静态方法
		不需要通过实例对象，可以直接通过类来调用的方法，其中的 this 指向类本身
		class Person {
		  static doSay () {
			this.say()
		  }
		  static say () {
			console.log('hello')
		  }
		}
		Person.doSay() // hello	
		
		静态方法可以被子类继承
		// ...
		class Sub extends Person {

		}
		Sub.doSay() // hello
		
		可以通过 super 对象访问
		// ...
		class Sub extends Person {
		  static nice () {
			return super.doSay()
		  }
		}
		Sub.nice() // hello
	6，严格模式
		不需要使用 use strict，因为只要代码写在类和模块内，就只能使用严格模式
	7，提升
		class 不存在变量提升。
			new Person() // Uncaught ReferenceError: Person is not defined
			class Person {

			}
	8，name 属性
		name 属性返回了类的名字，即紧跟在 class 后面的名字。
		class Person {

		}
		Person.name // Person
	9，this
		默认指向类的实例。
	10，取值函数（getter）和存值函数（setter）
		class Person {
		  get name () {
			return 'getter'
		  }
		  set name(val) {
			console.log('setter' + val)
		  }
		}

		let jon = new Person()
		jon.name = 'jon' // setter jon
		console.log(jon.name) // getter
	11，class 表达式
		如果需要，可为类定义一个类内部名字，如果不需要，可以省略：
		// 需要在类内部使用类名
		const Person = class Obj {
		  getClassName () {
			return Obj.name
		  }
		}
		console.log(new Person().getClassName())  // Obj
		// 不需要
		const Person = class {}
		
		立即执行的 Class：
		let jon = new class {
		  constructor(name) {
			this.name = name
		  }
		  sayName() {
			console.log(this.name)
		  }
		}('jon')

		jon.sayName() //jon



JavaScript中可以在某个元素前使用 ‘+’ 号，这个操作是将该元素转换秤Number类型，如果转换失败，那么将得到 NaN。
所以 +new Date 将会调用 Date.prototype 上的 valueOf 方法，而根据 MDN ，Date.prototype.valueOf 方法等同于 Date.prototype.getTime()
所以下列代码效果相同，返回的都是时间戳
	console.log(+new Date);
	console.log(new Date().getTime());
	console.log(new Date().valueOf());
	console.log(new Date() * 1);



主流浏览器引擎前缀:

-webkit- （谷歌，Safari，新版Opera浏览器，以及几乎所有iOS系统中的浏览器（包括 iOS 系统中的火狐浏览器）；基本上所有基于WebKit 内核的浏览器）
-moz- （火狐浏览器）
-o- （旧版Opera浏览器）
-ms- （IE浏览器 和 Edge浏览器）
示例:

-webkit-transition: all 4s ease;
-moz-transition: all 4s ease;
-ms-transition: all 4s ease;
-o-transition: all 4s ease;
transition: all 4s ease; 






// 禁止文字被鼠标选中
-webkit-user-select: none; 
-moz-user-select: none; 
-o-user-select: none; 
-ms-user-select: none; 
user-select: none;



静态的import 语句用于导入由另一个模块导出的内容。无论是否声明了 strict mode ，导入的模块都运行在严格模式下。在浏览器中，import 语句只能在声明了 type=“module” 的 script 的标签中使用
	<script type="text/javascript">
     
	</script
动态import
	关键字import可以像调用函数一样来动态的导入模块。以这种方式调用，将返回一个 promise。
	import('/modules/my-module.js').then(module => {
		// Do something
	})
	
	
	
	
div可以添加contenteditable="true"属性，将div变为可编辑的	
<div contenteditable="true" style="width:200px;height:100px;>这是一个div。是可编辑的。尝试修改文本。</div>	
	
	
	
Vue中插入HTML代码的方法	
	我们需要吧<p>Hello World</p>插入到<p>My name is Pjee</p>应该如何做？
	一、使用v-html
		v-html:更新元素的 innerHTML
		<p>
			My name is Pjee
			<p v-html='text'></p>
		</p>
		const text = `<p>Hello World</>`
	注意：你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 XSS 攻击。请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值。
	
	二、渲染函数
		渲染函数：这是通过对VNode（虚拟DOM）的操作来生成
			text(){
				render:(h)=>{
				  h(
					  'div', 
					  [
						h('p', 'Hello'),
						' world!'
					  ]
					)
				}
			}
			<p>Hello World{{this.text()}}</p>
		
	三、JSX	
		JSX：这个方法在React使用最为广泛，但是Vue中使用需要安装Babel插件
			text(){
				return (<p>Hello World</p>)
			}
			<p>Hello World{{this.text()}}</p>
		
	四、domPropsInnerHTML	
		domPropsInnerHTML：如果说JSX在vue很少用到，那么这个东西就更少有人使用到了
			const newText = '<p>How are you?</p>'
			text(){
			 return (
			   <p>
				 Hello World
				 <p domPropsInnerHTML={this.newText}></p>
				</p>
			 )
			}
			<p>Hello World{{this.text()}}</p>
		
		
		
		
再使用 VueRouter、MintUI 的时候，需要 Vue.use(VueRouter)、Vue.use(MintUI)，但axios 却不需要，这是为什么呢
		
	因为 axios 没有 install。	
	接下来我们自定义一个需要 Vue.use() 的组件，也就是有 install 的组件	
		在components目录下创建loading目录，在loading目录下：
		创建 Loading.vue
			<template>
				<div class="loading-box">
					Loading...
				</div>
			</template>
		创建index.js
			// 引入组件
			import LoadingComponent from './loading.vue'
			// 定义 Loading 对象
			const Loading={
				// install 是默认的方法。当外界在 use 这个组件的时候，就会调用本身的 install 方法，同时传一个 Vue 这个类的参数。
				install:function(Vue){
					Vue.component('Loading', LoadingComponent)
				}
			}
			// 导出
			export default Loading
		在main.js
			import Loading from './components/loading/index'
			Vue.use(Loading)
		
		使用
			<template>
			  <div>
				<Loading></Loading>
			  </div>
			</template>
		
		
		
递归：
一，阶乘函数（1*2*3*…*n的值)
	1，循环
		function sum(x){
		  let res = 1;
		  for(let i=2; i<=x; i++){
			res *= i;
		  }
		  return res
		}
		console.log(sum(5))
		i=2: 1*2的值赋给res
		i=3: 1*2*3的值赋给res
		i=4: 1*2*3*4的值赋给res
		i=5: 1*2*3*4*5的值赋给res
		
	2，递归
		function sum(x){
		  if(x == 1){
			return 1
		  }
		  return x * sum(x -1)
		}
		console.log(sum(5))
		第一次：5*sum(4) 等待，执行sum(4)
		第二次：4*sum(3) 等待，执行sum(3)
		第三次：3*sum(2) 等待，执行sum(2)
		第四次：2*sum(1) 不等待，返回2
		sum(2)有了结果，执行sum(3) 1*2*3
		sum(3)有了结果，执行sum(4) 1*2*3*4
		sum(4)有了结果，执行sum(5) 1*2*3*4*5
		
	let num = 234;
    console.log(num % 10)					//个位上数字 4
    console.log(parseInt((num%100)/10))		//十位上数字 3
    console.log(parseInt(num/100))			//百位上数字 2
	
	let num = 2345;							
    console.log(num % 10)					//个位上数字 5	   个位上的数字都是模以10
    console.log(parseInt((num%100)/10))		//十位上数字 4     模以100取得45，之后再除以10取得4.5 利用parseInt()取得4
    console.log(parseInt(num%1000/100))		//百位上数字 3	   模以1000取得345，之后再除以100取得3.45，利用parseInt()取得3
    console.log(parseInt(num/1000))			//千位上数字 2
	
二，求一个数字各个位数上的数字的和:  123   --->6 ---1+2+3
	function sum(x){
      if(x < 10){
        return x
      }
      return x%10 + sum(parseInt(x/10))
    }
    console.log(sum(1364))	 //14
	第一次：取1364最后一位4 + sum(136) 等待，执行sum(136)
	第二次：取136最后一位6 + sum(13) 等待，执行sum(13)
	第三次：取13最后一位3 + sum(1) 不等待，返回4
	sum(13)有了结果，执行 1+3+6
	sum(136)有了结果，执行 1+3+6+4	
		
		
		
		
chrome 快捷键
	打开新窗口	Ctrl + n
	打开新的标签页，并跳转到该标签页	Ctrl + t
	重新打开最后关闭的标签页，并跳转到该标签页	Ctrl + Shift + t
	跳转到下一个打开的标签页	Ctrl + Tab 或 Ctrl + PgDn
	跳转到上一个打开的标签页	Ctrl + Shift + Tab 或 Ctrl + PgUp
	关闭当前标签页	Ctrl + w 或 Ctrl + F4
	最小化当前窗口	Alt + 空格键 + n
	最大化当前窗口	Alt + 空格键 + x
	关闭当前窗口	Alt + F4
	退出 Google Chrome	Ctrl + Shift + q
	打开“开发者工具”	Ctrl + Shift + j 或 F12
	显示或隐藏书签栏	Ctrl + Shift + b
	打开查找栏搜索当前网页	Ctrl + f 或 F3
	跳转到与查找栏中搜索字词相匹配的下一条内容	Ctrl + g
	跳转到与查找栏中搜索字词相匹配的上一条内容	Ctrl + Shift + g
	重新加载当前网页	F5 或 Ctrl + r
	重新加载当前网页（忽略缓存的内容）	Shift + F5 或 Ctrl + Shift + r
	将当前网页保存为书签	Ctrl + d
			
		
		
		
微信小程序下拉刷新		
	在.json文件设置允许下拉刷新	
		如果想要设置全局页面允许刷新在app.json文件下编辑，单个页面允许刷新则在相应页面的.json文件编辑
		{
			"enablePullDownRefresh": true
		}
	在.js文件中设置刷新事件	
		同样，如果要设置全局页面刷新在app.js文件下编辑，单个页面刷新则在相应页面的.js文件编辑
		onPullDownRefresh: function () {
			wx.showNavigationBarLoading() //启用标题栏显示加载状态
			this.onShow() //调用相关方法
			setTimeout(() => {
			  wx.hideNavigationBarLoading() //隐藏标题栏显示加载状态
			  wx.stopPullDownRefresh() //结束刷新
			}, 2000); //设置执行时间
		},
		
		
微信小程序——wxParse使用方法		
	wxParse是一个微信小程序富文本解析组件。现在小程序里面自带了一个<rich-text>组件也能解析富文本，但是表现不尽人意。
	1.下载 wxParse，解压，将 wxParse 放入小程序中。	
		-components
			-wxParse
		-pages
	2.在 你需要引用这个插件的 wxml 文件中引用  wxParse.wxml	
		//路径根据你实际情况修改
		<import src="./../../../components/wxParse/wxParse" />
	3.在 你需要引用这个插件的 wxss 文件中引用  wxParse.wxss	
		/路径根据你实际情况修改
		@import './../../../components/wxParse/wxParse';
	4.在 你需要引用这个插件的 js 文件中引用  wxParse.js	
		//路径根据你的实际情况更改
		let WxParse = require('./../../../components/wxParse/wxParse')
	5.将你需要解析的内容进行解析	
	   /*
		* WxParse.wxParse(bindName , type, data, target,imagePadding)
		* 1.bindName绑定的数据名(必填)
		* 2.type可以为html或者md(必填)
		* 3.data为传入的具体数据(必填)
		* 4.target为Page对象,一般为this(必填)
		* 5.imagePadding为当图片自适应是左右的单一padding(默认为0,可选)
		*/
		let that=this;
		WxParse.wxParse('引用的时候的名字,如courseDetail', 'html', '你需要解析的数据,如courseDetailContent', that, 5)
		
		var that = this;
		WxParse.wxParse('courseDetail','html',res.data.content,that,5)
		
	6.在 wxml 文件中引用你解析出来的数据	
		//这里的courseDetail就是你上面的bindName
		<view>
			<template is="wxParse" data="{{wxParseData:courseDetail.nodes}}" />
		</view>
		
		<template is="wxParse" data="{{wxParseData:courseDetail.nodes}}" />
		
		


template选项的优先级比render选项的优先级高。这两个选项都是告诉vue如何去渲染页面的，同时只能有一个生效。
去掉demo的template代码，才会运行render函数：
HelloWorld.vue:
	<script>
		export default {
		  render(createElement) {
			console.log("this", this)
			return createElement("h1", 123);
		  }
		}
	</script>

	<style></style>

	

<body>
	<h1>指定区域全屏测试</h1>
	<button id="btn">全屏按钮</button>
	<div id="fulldiv">
	  <h1>这里是全屏显示的内容</h1>
	</div>
</body>
<script>
var fullscreen = false;
let btn = document.getElementById('btn');
let fullarea = document.getElementById('fulldiv')
btn.addEventListener('click',function(){  
  if (fullscreen) {    // 退出全屏
	if (document.exitFullscreen) {
	  document.exitFullscreen();
	} else if (document.webkitCancelFullScreen) {
	  document.webkitCancelFullScreen();
	} else if (document.mozCancelFullScreen) {
	  document.mozCancelFullScreen();
	} else if (document.msExitFullscreen) {
	  document.msExitFullscreen();
	}
  } else {    // 进入全屏
	if (fullarea.requestFullscreen) {
	  fullarea.requestFullscreen();
	} else if (fullarea.webkitRequestFullScreen) {
	  fullarea.webkitRequestFullScreen();
	} else if (fullarea.mozRequestFullScreen) {
	  fullarea.mozRequestFullScreen();
	} else if (fullarea.msRequestFullscreen) {
	  // IE11
	  fullarea.msRequestFullscreen();
	}
  }
  fullscreen = !fullscreen;
})
</script>


浏览器全屏“视觉环境”的默认背景色为黑色，如果你想改变背景色，可以使用如下css
#map-container:fullscreen {
  background-image: url('./../assets/image/bg.png');
}
#map-container:-webkit-full-screen {
  background-image: url('./../assets/image/bg.png');
}
#map-container:-moz-full-screen {
  background-image: url('./../assets/image/bg.png');
}



setTimeout 和 setInterval  第三个及以后的参数是用来给第一个参数传参的
	setTimeout((a,b,c) => {
		console.log(a,b,c)
	},1000, 1, 'hello', true)


//回到顶部
backTop() {
	document.body.scrollTop = 0
	document.documentElement.scrollTop = 0
}
<<<<<<< HEAD
=======



>>>>>>> 72f3a45596375094e0edc18884d5170ca77f98b8


什么是bfcache？

bfcache，即back-forward cache，可称为“往返缓存”，可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。这个缓存不仅保存页面数据，还保存了DOM和JS的状态，实际上是将整个页面都保存在内存里。如果页面位于bfcache中，那么再次打开该页面就不会触发onload事件

pageshow事件
这个事件在用户浏览网页时触发，pageshow 事件类似于 onload 事件，onload 事件在页面第一次加载时触发， pageshow 事件在每次加载页面时触发，即 onload 事件在页面从浏览器缓存中读取时不触发。

pagehide事件
该事件会在用户离开网页时触发。离开网页有多种方式。如点击一个链接，刷新页面，提交表单，关闭浏览器等。pagehide 事件有时可以替代 unload事件，但 unload 事件触发后无法缓存页面。

persisted属性
pageshow事件和pagehide事件的event对象还包含一个名为persisted的布尔值属性。

　　对于pageshow事件，如果页面是从bfcache中加载的，则这个属性的值为true；否则，这个属性的值为false。
　　对于pagehide事件，如果页面在卸载之后被保存在bfcache中，则这个属性的值为true；否则，这个属性的值为false。
 

不同的浏览器在对当前窗口‘打开’历史记录中的前一个页面的表现上并不统一，这和浏览器的实现以及页面本身的设置有关系。

解决方案：

javascript监听pageshow事件阻止页面进入bfcache

window.addEventListener('pageshow', function (e) {
     if (e.persisted) {
         window.location.reload()
     }
})
在uc和微信中测试通过，但是在某些安卓手机自带的浏览器中无效。

javascript监听pagehide事件阻止页面进入bfcache

window.addEventListener('pagehide', function (e) {
    var dom = document.body;
    dom.children.remove();
    setTimeout(function () {
        dom.appendChild("<script type='text/javascript'>window.location.reload();<\/script>");
    });
});
设置meta标签，清除页面缓存

<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />

		

设置 input 里面 placeholder 字体的颜色
	input::-webkit-input-placeholder,
	textarea::-webkit-input-placeholder {
	  color: #c7c7c7;
	}
	input:-moz-placeholder,
	textarea:-moz-placeholder {
	  color: #c7c7c7;
	}
	input:-ms-input-placeholder,
	textarea:-ms-input-placeholder {
	  color: #c7c7c7;
	}


设置字体禁止缩放
	body {
	  -webkit-text-size-adjust: 100% !important;
	  text-size-adjust: 100% !important;
	  -moz-text-size-adjust: 100% !important;
	}


vue-quill-editor回显不显示空格和缩进的解决方案
只需要加上 class="ql-editor" 就行了
<p class="ql-editor" v-html="content"></p>




for in 与 for of 的区别
	对数组的遍历大家最常用的就是for循环，ES5的话也可以使用forEach，ES5具有遍历数组功能的还有map、filter、some、every、reduce、reduceRight等，
	只不过他们的返回结果不一样。但是使用foreach遍历数组的话，使用break不能中断循环，使用return也不能返回到外层函数。

	Array.prototype.sayHello = function() {
	  console.log('Array')
	}
	Array.prototype.str = 'Array'
	let myArray = [1,2,33,40]
	myArray.name = '数组'
	for(let index in myArray){
	  console.log(index)            // 0 1 2 3 name sayHello str
	}


	Object.prototype.sayHello = function() {
	  console.log('Object')
	}
	Object.prototype.str = 'Object'
	let myObject = {name: 'jack', age: 24}
	for(let index in myObject) {
	  console.log(index)           // name age sayHello str
	}
	//如果不想让其输出原型中的属性和方法，可以使用hasOwnProperty方法进行过滤
	for(let index in myObject) {
	  if(myObject.hasOwnProperty(index)){
		console.log(index)         // name age
	  }
	}
	//你也可以用Object.keys()方法获取所有的自身可枚举属性组成的数组。
	Object.keys(myObject).forEach(key => console.log(myObject[key]))  // jack 24

	总结：使用for in 遍历数组返回的是数组的下标，属性名，以及其原型上的属性名和方法名
		  使用for in 遍历对象返回的是对象的属性名，以及其原型上的属性名和方法名
		注意：使用for in遍历数组返回的下标为 string 类型


	Object.prototype.sayHello = function() {
	  console.log('Object')
	}
	Object.prototype.str = 'Object'
	let myObject = {name: 'jack', age: 24}
	for(let index of myObject) {
	  console.log(index)             // TypeError: myObject is not iterable
	}
	
	Array.prototype.sayHello = function() {
	  console.log('Array')
	}
	Array.prototype.str = 'Array'
	let myArray = [1,2,33,40]
	myArray.name = '数组'
	for(let index of myArray){
	  console.log(index)			//1 2 33 40
	}

	总结：for in 遍历数组 不光遍历自身可迭代元素、属性、还会遍历其原型上的属性和方法，并且返回的都是下标，属性名，方法名
		  for of 只会遍历自身可迭代元素，返回的也是元素值。但for of 不能遍历对象



Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。





JavaScript中可迭代对象(iterable)
	JS 中的很多对象都是可迭代的。它们可能不是很好的察觉，但是如果仔细检查，就会发现迭代的特征：
		Arrays and TypedArrays
		Strings —— 遍历每个字符或Unicode代码点
		Maps —— 遍历其键-值对
		Sets —— 遍历元素
		arguments  —— 函数中类似数组的特殊变量
		DOM elements (Work in Progress)
	JS中使用迭代的其他一些结构是:
		for-of -- for-of 循环需要一个可迭代的对象，否则，它将抛出一个类型错误。
			for (const value of iterable) { ... }


	数组解构 -- 由于可迭代性，会发生析构。让我们来看看：
	const array = ['a', 'b', 'c', 'd', 'e'];
	const [first, ,third, ,last] = array;
	等价于:
	const array = ['a', 'b', 'c', 'd', 'e'];
	const iterator = array[Symbol.iterator]();
	const first = iterator.next().value
	iterator.next().value // Since it was skipped, so it's not assigned
	const third = iterator.next().value
	iterator.next().value // Since it was skipped, so it's not assigned
	const last = iterator.next().value

	扩展操作符(…)
	const array = ['a', 'b', 'c', 'd', 'e'];

	const newArray = [1, ...array, 2, 3];
	等价于：

	const array = ['a', 'b', 'c', 'd', 'e'];
	const iterator = array[Symbol.iterator]();
	const newArray = [1];
	for (let nextValue = iterator.next(); nextValue.done !== true; nextValue = iterator.next()) {
	  newArray.push(nextValue.value);
	}
	newArray.push(2)
	newArray.push(3)

	Promise.all 和 Promise.race 接受可迭代对象
	Maps 和 Sets


const myFavouriteAuthors = {
  allAuthors: {
    fiction: [
      'Agatha Christie', 
      'J. K. Rowling',
      'Dr. Seuss'
    ],
    scienceFiction: [
      'Neal Stephenson',
      'Arthur Clarke',
      'Isaac Asimov', 
      'Robert Heinlein'
    ],
    fantasy: [
      'J. R. R. Tolkien',
      'J. K. Rowling',
      'Terry Pratchett'
    ],
  },
  [Symbol.iterator]() {
    // 获取所有 genre
    const genres = Object.values(this.allAuthors)
    // 当前类型和索引
    let currentAuthorIndex = 0;
    let currentGenreIndex = 0;
    
    return {
      next: function() {
        // 获取当前类型下的作者信息
        const authors = genres[currentGenreIndex];
        //当前类型下作者是否已经遍历完
        if(currentAuthorIndex >= authors.length) {
          currentGenreIndex++;
          currentAuthorIndex = 0;
        }
        //类型是否已经遍历完
        if(currentGenreIndex >= genres.length) {
          return {
            value: undefined,
            done: true
          }
        }
        //返回正常数据
        return {
          value: genres[currentGenreIndex][currentAuthorIndex++],
          done: false
        }
      }
    }




  }
  // [Symbol.iterator]() {
  //   // 获取数组中的所有作者
  //   const genres = Object.values(this.allAuthors);
    
  //   // 存储当前类型和索引
  //   let currentAuthorIndex = 0;
  //   let currentGenreIndex = 0;
    
  //   return {
  //     // Implementation of next()
  //     next() {
  //       // 根据当前的索引获取对应的作者信息
  //       const authors = genres[currentGenreIndex];
        
  //       // 当遍历完数组 authors是,oNotHaveMoreAuthors 为 true
  //       const doNothaveMoreAuthors = !(currentAuthorIndex < authors.length);
  //       if (doNothaveMoreAuthors) {
  //        // 加一继续访问下一个
  //         currentGenreIndex++;
  //         // 重置
  //         currentAuthorIndex = 0;
  //       }
        
  //       // 如果所有 genres 都遍历完了结，那么我们需要告诉迭代器不能提供更多的值。
  //       const doNotHaveMoreGenres = !(currentGenreIndex < genres.length);
  //       if (doNotHaveMoreGenres) {
  //         return {
  //           value: undefined,
  //           done: true
  //         };
  //       }
        
  //       // 如果一切正常，从当genre 返回 作者和当前作者索引，以便下次，下一个作者可以返回。
  //       return {
  //         value: genres[currentGenreIndex][currentAuthorIndex++],
  //         done: false
  //       }
  //     }
  //   };
  // }
};

for (const author of myFavouriteAuthors) {
  console.log(author);
}




Iterator它是一种接口，为各种不同的数据结构提供统一的访问机制，即for...of循环。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作
ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”
ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被for...of循环遍历。原因在于，这些数据结构原生部署了Symbol.iterator属性，另外一些数据结构没有（比如对象）
原生具备 Iterator 接口的数据结构如下。
	Array
	Map
	Set
	String
	TypedArray
	函数的 arguments 对象
	NodeList 对象
有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法）
	（1）解构赋值
	对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。
	（2）扩展运算符
	扩展运算符（...）也会调用默认的 Iterator 接口。
只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组
break; 和 throw new Error()都会触发遍历器对象的return()函数
一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。

for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串
for...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for...in循环也不一样。
let arr = [3, 5, 7];
arr.foo = 'hello';

for (let i in arr) {
  console.log(i); // "0", "1", "2", "foo"
}

for (let i of arr) {
  console.log(i); //  "3", "5", "7"
}

数组提供内置的forEach方法
这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。




let声明的变量只在它所在的代码块有效
var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined
let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。
只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。

总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
if (true) {
  // TDZ开始
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
let不允许在相同作用域内，重复声明同一个变量。


ES5 只有全局作用域和函数作用域，没有块级作用域
let实际上为 JavaScript 新增了块级作用域。
ES6 允许块级作用域的任意嵌套。
内层作用域可以定义外层作用域的同名变量。

const声明一个只读的常量。一旦声明，常量的值就不能改变
const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值
const的作用域与let命令相同：只在声明所在的块级作用域内有效
const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
const声明的常量，也与let一样不可重复声明
const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
将对象彻底冻结的函数
var constantize = (obj) => {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) => {
    if ( typeof obj[key] === 'object' ) {
      constantize( obj[key] );
    }
  });
};
freeze只能冻结基本类型的属性，遇到属性为object的，还需要在冻结

ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。

顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。
window.a = 1;
a // 1

a = 2;
window.a // 2
上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。
顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。
ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩
var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined









