02，数据类型
	1，分类
		基本(值)类型
			String: 任意字符串
			Number: 任意的数字
			Boolean: true/false
			Undefined: undefined
			Null: null
		对象(引用)类型
			Object: 任意对象
			Function: 一种特别的对象(可以执行)
			Array: 一种特别的对象(内部数据是有序的，通过数值下标访问)
	2，判断
		typeof
			可以判断: undefined , 数值, 字符串, 布尔值, function
			不能区别: null和object   object与array
		instanceof
			判断对象的具体类型
		===
			可以判断: undefined, null
			
		你得先知道你得到的是什么类型的数据，你才能确定下一步要怎么操作	
		<script>
			//1,基本
			//typeof 返回数据类型的字符串表达
			var a;
			console.log(a, typeof a, typeof a==='undefined', a===undefined);   //undefined 'undefined', true, true
			console.log(undefined==='undefined'); //false
			
			a = 3;
			console.log(typeof a === 'number');  //true  不能使用a===3判断a的类型，因为a的值也有可能为其他数字
			
			a = "hello";
			console.log(typeof a === 'string'); //true
			
			a = true;
			console.log(typeof a === 'boolean');
			
			a = null;
			console.log(typeof a, a===null);   //'object' 无法使用typeof 判断null
			
			//2,对象
			var b1 = {
				b2: [1, 'abc', console.log],
				b3: function(){
					console.log('b3');
					return function(){
						return "hello"
					}
				}
			}
			console.log(b1 instanceof Object, b1 instanceof Array); //true false
			console.log(b1.b2 instanceof Array, b1.b2 instanceof Object); //true true
			console.log(b1.b3 instanceof Function, b1.b3 instanceof Object); //true true
			
			console.log(typeof b1.b2); //'object'
			
			console.log(typeof b1.b3 === 'function'); //true
			
			console.log(typeof b1.b2[2] === 'function'); //true
			b1.b2[2](4)  //4
			console.log(b1.b3()()); //hello   
			
		</script>
		
		
03, 高级问题
	1,undefined与null的区别
		undefined代表定义未赋值
		null定义并赋值了，只是值为null
	2,什么时候给变量赋值为null呢？
		初始赋值，表明将要赋值为对象
		结束前，让对象成为垃圾对象(被垃圾回收器回收)
	3,严格区分变量类型与数据类型
		数据的类型
			基本类型
			对象类型
		变量的类型(变量内存值的类型)
			基本类型：保存的是基本类型的值
			引用类型：保存的是地址值
	
	
	
	<script>
		//实例：实例对象
		//类型：类型对象
		function Person(name, age){  //构造函数  类型
			this.name = name;
			this.age = age;
		}
		var p = new Person('tom', 12); //根据类型创建的实例对象
		
		
		//1,undefined与null的区别
		var a;
		console.log(a); //undefined
		a = null;
		console.log(a); //null
		
		//起始
		var b = null; //初始赋值为null，表明将要赋值为对象(编程需要严谨，不设为null当然可以，但不推荐)
		//确定对象并赋值
		b = [1,4];
		//最后
		b = null; //让b指向的对象成为垃圾对象(被垃圾回收器回收)
		//b = 2; 这么做也可以进行回收，但不推荐
		
		var c = function(){};
		console.log(typeof c); //'function' 只检查c的值是无法判断的，需要检查堆内存中的值才能给出结果
	</script>
	
	
04，数据-变量-内存
	1，什么是数据？
		存储在内存中代表特定信息的'东东'，本质上是0101...
		数据的特点：可传递，可运算
		一切皆数据
		内存中所有操作的目标：数据
			算术运算
			逻辑运算
			赋值
			运行函数
	2，什么是内存？
		内存条通电后产生的可储存数据的空间(临时的)
		内存产生和死亡：内存条(电路板)=>通电=>产生内存空间=>存储数据=>处理数据=>断电=>内存空间和数据都消失
		一块小内存的2个数据
			内部存储的数据
			地址值
		内存分类
			栈：全局变量/局部变量
			堆：对象
	3，什么是变量？
		可变化的量，由变量名和变量值组成
		每个变量都对应一块小内存，变量名用来查找对应的内存，变量值就是内存中保存的数据
	4，内存，数据，变量三者之间的关系
		内存用来存储数据的空间
		变量是内存的标识
		
05，06，相关问题
	关于赋值和内存的问题
		问题：var a = xxx;   a内存中到底保存的是什么
			xxx是基本数据，保存的就是这个数据
			xxx是对象，保存的是对象的地址值
			xxx是一个变量，保存的xxx的内存内容(可能是基本数据，也可能上地址值)
			
	关于引用变量赋值问题
		2个引用变量指向同一个对象，通过一个变量修改对象内部数据，另一个变量看到的是修改之后的数据
		2个引用变量指向同一个对象，让其中一个引用变量指向另一个对象，另一个引用变量依然指向前一个对象
			var a = {age: 12};
			function fn(obj){
				obj = {age: 15};
			}
			fn(a);
			console.log(a.age); //12
	关于数据传递问题
		问题：在js调用函数时传递变量参数时，是值传递还是引用传递
			理解1：都是值(基本值，地址值)传递
			理解2：可能是值传递，也可能是引用传递(地址值)
			
	内存管理
		问题：js引擎如何管理内存
			1，内存生命周期
				分配小内存空间，得到他的使用权
				存储数据，可以反复进行操作
				释放小内存空间
			2，释放内存
				局部变量：函数执行完自动释放
				对象：成为垃圾对象=>垃圾回收器回收
			
			function fn(){
				var b = {};
			}
			fn(); //b是自动释放，b所指向的对象是在后面的某个时刻由垃圾回收器回收
			
		
07，对象
	1，什么是对象
		多个数据的封装体
		用来保存多个数据的容器
		一个对象代表现实中的一个事物
	2，为什么要用对象
		统一管理多个数据
	3，对象的组成
		属性：属性名(字符串)和属性值(任意)组成
		方法：一种特别的属性(属性值是函数)
	4，如何访问对象内部数据
		.属性名：编码简单，有时不能用
		['属性名']：编码复杂，能通用
			什么时候必须使用['属性名']的方式？
				1，属性名包含特殊字符： - 空格
				2，属性名不确定
				
				
				var p = {};
				//1，给p对象添加一个属性：content-type:text/json
				//p.content-type = 'text/json'; //不能用
				p['content-type'] = 'text/json';
				console.log(p['content-type']); //text/json
				
				//2，属性名不确定
				var propName = "myAge";
				var value = 18;
				//p.propName = value;
				p[propName] = value;
				console.log(p[propName]); // 18
		
	<script>
		var p = {
			name: 'Tom',
			age: 12,
			setName: function(name){
				this.name = name;
			},
			setAge(age){
				this.age = age;
			}
		}
		p.setName('Jack');
		p['setAge'](23);
		console.log(p.name, p['age']);
	</script>
	
	
08，函数
	1，什么是函数？
		实现特定功能的n条语句的封装体
		只有函数是可以执行的，其他类型的数据不能执行
	2，为什么要用函数？
		提高代码复用
		便于阅读交流
	3，如何定义函数？
		函数声明
		表达式
	4，如何调用(执行)函数？
		test() :直接调用
		obj.test() :通过对象调用
		new Test() :new调用
		test.call/apply(obj) :临时让test成为obj的方法进行调用
	
	
	function fn(){ //函数声明
	
	}
	var fn2 = function(){ //表达式
	
	}
	fn();
	fn2();
	
	var obj = {};
	function test2(){
		this.xxx = "hello";
	}
	//obj.test2(); 不能直接调用，根本就没有
	test2.call(obj); //obj.test2()  //可以让一个函数成为指定任意对象的方法进行调用
	console.log(obj.xxx); //hello
	
09，回调函数
	1，什么函数才是回调函数
		1)，你定义的
		2)，你没有调
		3)，但最终它执行了(在某个时刻或某个条件下)
	2，常见的回调函数
		dom事件回调函数  ==> 发生事件的dom元素
		定时器回调函数  ==> window
		
		ajax请求回调函数(后面讲)
		生命周期回调函数(后面讲)
	
	
	document.getElementById('btn').onclick = function(){  //dom事件回调函数
		alert(this.innerHTML);
	}
	
	setTimeout(function(){  //定时器回调函数
		alert('hello');
	},1000)
	
10，IIFE
	1，理解
		全称：Immediately-Invoked Function Expression  立即调用函数表达式
	2，作用
		隐藏实现
		不会污染外部(全局)命名空间
		用它来编写js模块
	
	(function(){  //匿名函数自调用
		var a = 123;
		console.log(a);
	})()
	
	
	(function(){
		var a = 1;
		function test(){
			console.log(++a);
		}
		window.$ = function(){  //向外暴露一个全局函数
			return {
				test: test
			}
		}
	})()
	$().test() //2  $是一个函数   $执行后返回的是一个对象
	
	
11，函数中的this
		1,this是什么
			任何函数本质上都是通过某个对象来调用的，如果没有直接指定，就是window
			所有函数内部都有一个变量this
			他的值是调用函数的当前对象
		2，如何确定this的值
			test() : window
			p.test() : p
			new test() : 新创建的对象
			p.call(obj) : obj
	
12，关于语句分号问题
	1，js一条语句的后面可以不加分号
	2，是否加分号是编码风格问题，没有应该不应该，只有你自己喜欢不喜欢
	3，在下面2种情况下不加分号会有问题
		小括号开头的前一条语句
			var a = 3
			;(function(){
				
			})()
			//错误理解成  var a = 3(function(){})()
							
		中方括号开头的前一条语句
			var b = 4
			[1, 3].forEach(function(item, index, arr))
			//错误理解成  var b = 4[1, 3].forEach(function(item, index, arr))
	4，解决办法：在行首加分号
	5，强有力的例子：vue.js
	6，https://www.zhihu.com/question/20298345
	
13，webstorm设置
	
14，复习

15，函数的prototype
	1，函数的prototype属性
		每个函数都有一个prototype属性，它默认指向一个Object空对象(即称为：原型对象)
		原型对象中有一个属性constructor，它指向函数对象
	2，给原型对象添加属性(一般都是方法)
		作用：函数的所有实例对象自动拥有原型中的属性(方法)
		
		<script>
		    //每个函数都有一个prototype属性，它默认指向一个Object空对象(即称为：原型对象)
			console.log(Date.prototype, typeof Date.prototype);
			function Funun(){
			
			}
			console.log(Fun.prototype); //默认指向一个object空对象(没有我们的属性)
			
			console.log(Fun.prototype); 
			
			
			//原型对象中有一个属性constructor，它指向函数对象
			console.log(Date.prototype.constructor === Date); // true
			console.log(Fun.prototype.constructor === Fun); //true
			
			
			//给原型对象添加属性(一般都是方法) ==> 实例对象可以访问
			Fun.prototype.test = function(){
				console.log("test");
			}
			var fun = new Fun();
			fun.test(); //test
		</script>
		
16，显式原型与隐式原型
	1，每个函数function都有一个prototype，即显式原型(属性)
	2，每个实例对象都有一个__proto__，可称为隐式原型(属性)
	3，对象的隐式原型的值为其对应构造函数的显式原型的值
	4，内存结构
	5，总结：
		函数的prototype属性：在定义函数时自动添加的，默认值是一个空object对象
		对象的__proto__属性：创建对象时自动添加的，默认值为构造函数的prototype属性值
		程序员能直接操作显式原型，但不能直接操作隐式原型(ES6之前)
		
		<script>
			function Fn(){ //内部语句：this.prototype = {}
			}
			//1，每个函数function都有一个prototype，即显式原型(属性)，默认指向一个空的object对象
			console.log(Fn.prototype);
			//2，每个实例对象都有一个__proto__，可称为隐式原型(属性)，
			var fn = new Fn(); //内部语句：this.__proto__ = Fn.prototype
			console.log(fn.__proto__);
			
			console.log(Fn.prototype === fn.__proto__); //true
			
			//给原型添加方法
			Fn.prototype.test = function(){
				console.log(123);
			}
			fn.test(); //123
		</script>
	
17，原型链
	1，原型链(图解)
		访问一个对象的属性时
			先在自身属性中查找，找到返回
			如果没有，再沿着__proto__这条链向上查找，找到返回
			如果最终没找到，返回undefined
		别名：隐式原型链
		作用：查找对象的属性(方法)
	2，构造函数/原型/实体对象的关系
	
	
18，19，原型链补充
	1，读取对象的属性值时：会自动到原型链中查找
	2，设置对象的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值
	3，方法一般定义在原型中，属性一般通过构造函数定义在对象本身上
	
	
20，instanceof
	1，instanceof是如何判断的
		表达式 A instanceof B
			如果B函数的显式原型对象在A对象的原型链上，返回true，否则返回false
	2，Function是通过new自己产生的实例
	
21，

22，变量提升与函数提升
	1，变量声明提升
		通过var定义(声明)的变量，在定义语句之前就可以访问到
		值：undefined
	2，函数声明提升
		通过function声明的函数，在之前就可以直接调用
		值：函数定义(对象)
	
23，执行上下文
	1，代码分类(位置)
		全局代码
		函数代码
	2，全局执行上下文
		在执行全局代码前将window确定为全局执行上下文
		对全局数据进行预处理
			var定义的全局变量 => undefined，添加为window的属性
			function声明的全局函数 => 赋值(fun)，添加为window的方法
			this => 赋值(window)
	3，函数执行上下文
		在调用函数，准备执行函数之前，创建对应的函数执行上下文对象
		对局部数据进行预处理
			形参变量=>赋值(实参)==>添加为执行上下文的属性
			arguments=>赋值(实参列表)，添加为执行上下文的属性
			var定义的局部变量=>undefined，添加为执行上下文的属性
			function声明的函数 =>赋值(fun)，添加为执行上下文的方法
			this=>赋值(调用函数的对象)
		开始执行函数体代码
		
24，执行上下文栈
	1，在全局代码执行前，js引擎就会创建一个栈来存储管理所有的执行上下文对象
	2，在全局执行上下文(window)确定后，将其添加到栈中(压栈)
	3，在函数执行上下文创建后，将其添加到栈中(压栈)
	4，在当前函数执行完后，将栈顶的对象移除(出栈)
	5,当所有的代码执行完后，栈中只剩下window
	
25,26

27,作用域与作用域链
	1，理解
		就是一块'地盘'，一个代码段所在的区域
		它是静态的(相对于上下文对象)，在编写代码时就确定了
	2，分类
		全局作用域
		函数作用域
		没有块作用域(ES6有了)
	3，作用
		隔离变量，不同作用域下同名变量不会有冲突
		
28，

29，循环遍历加监听

30，闭包理解
	1，如何产生闭包
		当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时，就产生了闭包
	2，闭包到底是什么
		使用chrome调试查看
		理解一：闭包是嵌套的内部函数(绝大部分人)
		理解二：包含被引用变量(函数)的对象(极少部分人)
		注意：闭包存在于嵌套的内部函数中
	3，产生闭包的条件
		函数嵌套
		内部函数引用了外部函数的数据(变量/函数)
		
31，32，常见闭包
	1，将函数作为另一个函数的返回值
	2，将函数作为实参传递给另一个函数调用
		function fn1(){
			var a = 2;
			function fn2(){
				a++;
				console.log(a);
			}
			return fn2;
		}
		var f = fn1(); //外部函数调用几次，就会创建几个闭包
		f(); //3
		f(); //4
		
		//产生闭包的两个条件：1，有内部函数，2，内部函数里使用了外部函数的变量或函数
		
		function showDelay(msg, time){
			setTimeout(function(){
				alert(msg);
			}, time)
		}
		showDelay('hello', 2000);
		
		
	闭包的作用
		1，使用函数内部的变量在函数执行完后，仍然存活在内存中(延长了局部变量的生命周期)
			一般是不存在，存在于闭包中的变量才可能存在			
		2，让函数外部可以操作(读写)到函数内部的数据(变量/函数)
			不能，但我们可以通过闭包让外部操作它
		
33，闭包的生命周期
	1，产生：在嵌套内部函数定义执行完时就产生了(不是在调用)
	2，死亡：在嵌套的内部函数成为垃圾对象时
		function fn1(){
			//此时闭包就已经产生了(函数提升，内部函数对象已经创建了)
			var a = 2;
			function fn2(){
				a++;
				console.log(a);
			}
			return fn2;
		}
		var f = fn1(); 
		f(); //3
		f(); //4
		f = null //闭包死亡
		
34，闭包应用
	闭包的应用：定义js模块
		具有特定功能的js文件
		将所有的数据和功能都封装在一个函数内部(私有的)    //封装在对象内不算私有，因为你可以对象名.属性名去访问
		只向外暴露一个包含n个方法的对象或函数
		模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能
		
			myModule.js
				function myModule(){
					//私有数据
					var msg = 'hello';
					//操作数据的函数
					function doSomething(){
						console.log(msg.toUpperCase());
					}
					function doOtherthing(){
						console.log(msg.toLowerCase());
					}
					//向外暴露对象(给外部使用的方法)
					return {
						doSomething: doSomething,
						doOtherthing: doOtherthing
					}
				}
			<script src="myModule.js"></script>
			var module = myModule()
			module.doSomething()
			module.doOtherthing()
			
			myModule2.js
				(function(){
					//私有数据
					var msg = 'hello';
					//操作数据的函数
					function doSomething(){
						console.log(msg.toUpperCase());
					}
					function doOtherthing(){
						console.log(msg.toLowerCase());
					}
					//向外暴露对象(给外部使用的方法)
					window.Module2 = {
						doSomething: doSomething,
						doOtherthing: doOtherthing
					}
				})()
			<script src="myModule2.js"></script>
			module2.doSomething()
			module2.doOtherthing()
			
35，闭包的缺点
	缺点
		函数执行完后，函数内的局部变量没有释放，占用内存时间会变长
		容易造成内存泄漏
	解决
		能不用闭包就不用
		及时释放
			function fn1(){
				var name = 'jack'
				function fn2(){
					console.log(name);
				}
				return fn2;
			}
			var f = fn1()
			f()
			
			f = null   //让内部函数成为垃圾对象 ==> 回收闭包
			
	内存溢出与内存泄露
		1，内存溢出
			一种程序运行出现的错误
			当程序运行需要的内存超过了剩余的内存时就会抛出内存溢出的错误
		2，内存泄露
			占用的内存没有及时释放
			内存泄露积累多了就容易导致内存溢出
			常见的内存泄露
				意外的全局变量
					function fn(){
						a = 3;
					}
					fn()
				没有及时清理的计时器或回调函数
					var timer = setInterval(function(){
						console.log(112);
					}, 1000)
					// clearInterval(timer);
				闭包
					上方 f = null 没写的话
					
36，面试题
	//片段一
	var name = 'the window';
	var object = {
		name: 'the object',
		getNameFun: function(){
			return function(){
				return this.name
			}
		}
	}
	alert(object.getNameFun()())  //the window
	
	//片段二
	var name = 'the window';
	var object = {
		name: 'the object',
		getNameFun: function(){
			var that = this;
			return function(){
				return that.name
			}
		}
	}
	alert(object.getNameFun()())  //the object
	
	
37，对象创建模式
	方式一：Object构造函数模式
		套路：先创建空Object对象，再动态添加属性/方法
		适用场景：起始时不确定对象内部数据
		问题：语句太多
			var p =new Object()  //大写O
			p.name = 'jack'
			p.setName = function(){
				this.name = '123'
			}
			
	方式二：对象字面量模式
		套路：使用{}创建对象，同时指定属性/方法
		适用场景：起始时对象内部数据是确定的
		问题：如果创建多个对象，有重复代码
			var p = {
				name: 'jack',
				setName: function(){
					this.name = '123'
				}
			}
	方式三：工厂模式
		套路：通过工厂函数动态创建对象并返回
		适用场景：需要创建多个对象
		问题：对象没有一个具体的类型，都是Object类型
			function createPerson(name, age){
				var obj = {
					name: name,
					age: age,
					setName: function(){
						this.name = name;
					}
					
				}
				return obj;
			}
			var p1 = createPerson('jack', 12);
			var p2 = createPerson('tom', 33);
			
	方式四：自定义构造函数模式
		套路：自定义构造函数，通过new创建对象
		适用场景：需要创建多个类型确定的对象
		问题：每个对象都有相同的数据，浪费内存
			function Person(name, age){
				this.name = name;
				this.age = age;
				this.setName = function(name){
					this.name = name;
				}
			}
			var p1 = new Person('jack', 33)
			var p2 = new Person('tom', 22)
			
	方式五：构造函数+原型的组合模式
		套路：自定义构造函数，属性在函数中初始化，方法添加到原型上
		适用场景：需要创建多个类型确定的对象
			function Person(name, age){
				this.name = name;
				this.age = age;
				
			}
			Person.prototype.setName = function(name){
				this.name = name;
			}
			var p1 = new Person('jack', 33)
			var p2 = new Person('tom', 22)
			
			
38，原型链继承
	1，套路
		1，定义父类型构造函数
		2，给父类型的原型添加方法
		3，定义子类型的构造函数
		4，创建父类型的对象赋值给子类型的原型
		5，将子类型原型的构造属性设置为子类型
		6，给子类型原型添加方法
		7，创建子类型的对象：可以调用父类型的方法
	2，关键
		1，子类型的原型为父类型的一个实例对象
			//子类型
			function Supper(){
				this.subProp = "supper property"
			}
			Supper.prototype.showSubProp = function(){
				console.log(this.subProp)
			}
			//父类型
			function Sub(){
				this.subProp = "sub property"
			}
			//子类型的原型为父类型的一个实例对象
			Sub.prototype = new Supper()
			//让子类型的原型的constructor指向子类型
			Sub.prototype.constructor = Sub
			var sub = new Sub()
			sub.showSubProp()
			
			console.log(sub.constructor) 
			
39,组合继承
	方式2：借用构造函数继承(假的)
		1，套路：
			1，定义父类型构造函数
			2，定义子类型构造函数
			3，在子类型构造函数中调用父类型构造
		2，关键
			1，在子类型构造函数中通过super()调用父类型的构造函数
				function Person(name, age){
					this.name = name;
					this.age = age;
				}
				function Student(name, age, price){
					Person.call(this, name, age) //相当于：this.Person(name, age)
					this.price = price
				}
				
				
	方式3：组合继承：原型链+借用构造函数的组合继承
		1，利用原型链实现对父类型对象的方法继承
		2，利用super()借用父类型构造函数初始化相同属性
			function Person(name, age){
				this.name = name;
				this.age = age;
			}
			Person.prototype.setName = function(name){
				this.name = name
			}
			function Student(name, age, price){
				Person.call(this, name, age)  //为了得到属性
				this.price = price
			}
			Student.prototype = new Person() //为了能看到父类型的方法
			Student.prototype.constructor = Student //修正constructor属性
			Student.prototype.setPrice = function(price){
				this.price = price
			}
			
			var s = new Student('tom', 12 , 14000);
			s.setName('bob')
			s.setPrice(1200)
			console.log(s.name, s.age, s.price)  //bob 12 1200
			
40

41

42,进程与线程
	进程：程序的一次执行，它占有一片独有的内存空间。可以通过windows任务管理器查看进程
	线程：是进程内的一个独立执行单元，是程序执行的一个完整流程，是cpu的最小的调度单元
	
	单线程程序：指的是一个进程内只有一个线程，如果他有多个进程，但每个进程内只有一个线程，也是单线程程序
	
	相关知识：
		应用程序必须运行在某个进程的某个线程上
		一个进程至少有一个运行的线程：主线程，进程启动后自动创建
		一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的
		一个进程内的数据可以供其中的多个线程直接共享
		多个进程之间的数据是不能直接共享的
		线程池(thread pool)：保存多个线程对象的容器，实现线程对象的反复利用
		
	问题：
		1，何为多进程与多线程
			多进程运行：一个应用程序可以同时启动多个实例运行
			多线程：在一个进程内，同时有多个线程运行
		2，比较单线程与多线程
			多线程：
				优点：能有效提升cpu利用率
				缺点：创建多线程开销
					  线程间切换开销
					  死锁与状态同步问题
					  
			单线程：
				优点：顺序编程简单易懂
				缺点：效率低
		3，js是单线程还是多线程
			js是单线程运行的
			但使用h5中的Web Workers可以多线程运行
		4，浏览器运行是单线程还是多线程
				都是多线程运行的
		5，浏览器运行时单进程还是多进程
			有的是单进程
				firefox
				老版IE
			有的是多进程
				chrome
				新版IE
			如何查看浏览器是否是多进程运行的呢
			
43，浏览器内核
	支撑浏览器运行的最核心的程序
	不同的浏览器可能不一样
		chrome，safari: webkit
		firefox: gecko
		IE: trident
		360,搜狗等国内浏览器：trident + webkit
	内核有很多模块组成
		js引擎模块：负责js程序的编译与运行
		html，css文档解析模块：负责页面文本的解析
		DOM/css模块：负责dom/css在内存中的相关处理
		布局和渲染模块：负责页面的布局和效果的绘制(内存中的对象)     (这四个   主线程)
		...
		定时器模块：负责定时器的管理
		事件响应模块：负责事件的管理
		网络请求模块：负责ajax请求     (这三个  分线程)
		
44，定时器的一些思考
	1，定时器真是定时执行的吗
		定时器并不能保证真的定时执行
		一般会延迟一丁点(可以接受)，也有可能延迟很长时间(不能接受)
	2，定时器回调函数是在分线程执行的吗
		在主线程执行的，js是单线程的
	3，定时器是如何实现的
		事件循环模型(后面讲)
		
45，js是单线程执行的
	1，如何证明js执行时单线程的
		setTimeout()的回调函数是在主线程执行的
		定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行
	2，为什么js要用单线程模式，而不用多线程模式
		js的单线程，与它的用途有关
		作为浏览器脚本语言，js的主要用途是与用户互动，以及操作DOM
		这决定了它只能是单线程，否则会带来很复杂的同步问题
	3，代码的分类
		初始化代码
		回调代码
	4，js引擎执行代码的基本流程
		先执行初始化代码：包含一些特别的代码
			设置定时器
			绑定事件监听
			发送ajax请求
		后面在某个时刻才会执行回调函数
		
46，事件循环模型
	1，所有代码分类
		初始化执行代码(同步代码)：包含绑定dom事件监听，设置定时器，发送ajax请求的代码
		回调执行代码(异步代码)：处理回调逻辑
	2，js引擎执行代码的基本流程
		初始化代码 => 回调代码
	3，模型的2个重要组成部分：
		事件管理模块
		回调队列
	4，模型的运转流程
		执行初始化代码，将事件回调函数交给对应模块管理
		当事件发生时，管理模块会将回调函数及其数据添加到回调队列中
		只有当初始化代码执行完后(可能要一定时间)，才会遍历读取回调队列中的回调函数执行
		
	相关重要概念：
		1，执行栈  execution stack  所有的代码都是在此空间中执行的
		2，浏览器内核
			browser core
			js引擎模块(在主线程处理)
			其他模块(在主/分线程处理)
		3，任务队列  task queue		 	
		4，消息队列  message queue
		5，事件队列  event queue    (3,4,5 同一个callback queue)
		6，事件轮询
			event loop
			从任务队列中循环取出回调函数放入执行栈中处理(一个接一个)
		7，事件驱动模型  event-drivent interaction model
		8，请求响应模型  request-response model
		
47,web workers
	1，h5规范提供了js分线程的实现，取名为：Web Workers
	2，相关api
		Worker: 构造函数，加载分线程执行的js文件
		Worker.prototype.onmessage：用于接受另一个线程的回调函数
		Worker.prototype.postMessage：向另一个线程发送消息
	3，不足
		worker内代码不能操作dom(更新ui)
		不能跨域加载js
		不是每个浏览器都支持这个新特性