语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值
语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。
var a = 1 + 3 ; var b = 'abc';
表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。
1 + 3;
'abc';
中文是合法的标识符，可以用作变量名。

var 临时变量 = 1;

对于var命令来说，JavaScript 的区块不构成单独的作用域（scope）。

注意，if后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。

var x = 1;
var y = 2;
if (x = y) {
  console.log(x);
}
// "2"
上面代码的原意是，当x等于y的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将y赋值给变量x，再判断变量x的值（等于 2）的布尔值（结果为true）。

这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。

if (x = 2) { // 不报错
if (2 = x) { // 报错

每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构
var x = 1;

switch (x) {
  case 1:
    console.log('x 等于1');
  case 2:
    console.log('x 等于2');
  default:
    console.log('x 等于其他值');
}
// x等于1
// x等于2
// x等于其他值

上面代码中，case代码块之中没有break语句，导致不会跳出switch结构，而会一直执行下去。正确的写法是像下面这样。
switch (x) {
  case 1:
    console.log('x 等于1');
    break;
  case 2:
    console.log('x 等于2');
    break;
  default:
    console.log('x 等于其他值');
}

需要注意的是，switch语句后面的表达式，与case语句后面的表示式比较运行结果时，采用的是严格相等运算符（===），而不是相等运算符（==），这意味着比较时不会发生类型转换。
var x = 1;

switch (x) {
  case true:
    console.log('x 发生类型转换');
    break;
  default:
    console.log('x 没有发生类型转换');
}
// x 没有发生类型转换


所有for循环，都可以改写成while循环
var x = 3;
for (var i = 0; i < x; i++) {
  console.log(i);
}

var x = 3;
var i = 0;

while (i < x) {
  console.log(i);
  i++;
}

break语句用于跳出代码块或循环。
continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。
如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环

标签通常与break语句和continue语句配合使用，跳出特定的循环。
top:
  for (var i = 0; i < 3; i++){
    for (var j = 0; j < 3; j++){
      if (i === 1 && j === 1) break top;  满足条件时，直接跳出双层循环(如果是continue，会跳过当前循环，直接进入下一轮外层循环)
      console.log('i=' + i + ', j=' + j);
    }
  }

标签也可以用于跳出代码块。
foo: {
  console.log(1);
  break foo;
  console.log('本行不会输出');
}
console.log(2);



JavaScript 有三种方法，可以确定一个值到底是什么类型。
typeof运算符
instanceof运算符
Object.prototype.toString方法

空数组（[]）的类型也是object
typeof [] // 'object'
但 instanceof 运算符可以区分数组和对象
var o = {};
var a = [];

o instanceof Array // false
a instanceof Array // true



null与undefined都可以表示 “没有”，含义非常相似。将一个变量赋值为undefined或null，老实说，语法效果几乎没区别。
在if语句中，它们都会被自动转为false，相等运算符（==）甚至直接报告两者相等。
区别是这样的：null是一个表示 “空” 的对象，转为数值时为0；undefined是一个表示 "此处无定义" 的原始值，转为数值时为NaN。
Number(null) //0
Number(undefined) // NaN

null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null，表示该参数为空。
undefined表示 “未定义”，下面是返回undefined的典型场景。
	// 变量声明了，但没有赋值
	var i;
	i // undefined

	// 调用函数时，应该提供的参数没有提供，该参数等于 undefined
	function f(x) {
	  return x;
	}
	f() // undefined

	// 对象没有赋值的属性
	var  o = new Object();
	o.p // undefined

	// 函数没有返回值时，默认返回 undefined
	function f() {}
	f() // undefined



undefined  null   false  0  NaN  ""或''（空字符串）        这六个值被转为false，其他值都视为true

注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。
if ([]) {
  console.log('true');
}
// true

if ({}) {
  console.log('true');
}
// true


由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。
0.1 + 0.2 === 0.3
// false

0.3 / 0.1
// 2.9999999999999996

(0.3 - 0.2) === (0.2 - 0.1)
// false


精度最多只能到 53 个二进制位，这意味着，绝对值小于 2 的 53 次方的整数，即 - 2^53 到 2^53，都可以精确表示。
Math.pow(2, 53)
// 9007199254740992

Math.pow(2, 53) + 1
// 9007199254740992

Math.pow(2, 53) + 2
// 9007199254740994

Math.pow(2, 53) + 3
// 9007199254740996

Math.pow(2, 53) + 4
// 9007199254740996

Math.pow(x,y) 返回值 x的 y 次幂
上面代码中，大于 2 的 53 次方以后，整数运算的结果开始出现错误。所以，大于 2 的 53 次方的数值，都无法保持精度。由于 2 的 53 次方是一个 16 位的十进制数值，所以简单的法则就是，JavaScript 对 15 位的十进制数都可以精确处理。


如果一个数大于等于 2 的 1024 次方，那么就会发生 “正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。
Math.pow(2, 1024) // Infinity

如果一个数小于等于 2 的 - 1075 次方（指数部分最小值 - 1023，再加上小数部分的 52 位），那么就会发生为 “负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回 0。
Math.pow(2, -1075) // 0

JavaScript 提供Number对象的MAX_VALUE和MIN_VALUE属性，返回可以表示的具体的最大值和最小值。
Number.MAX_VALUE // 1.7976931348623157e+308
Number.MIN_VALUE // 5e-324

































