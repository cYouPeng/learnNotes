1，
	library 库   jquery
	runtime 运行环境 node

	LTS 最新稳定版
	current 最新版

2，
	
	
	node.js 可以在任何操作系统上安装，底层都是chrome v8 引擎 使用c++开发
	
	cmd commond的简写
	系统的环境变量中的path值，使得我们可以在cmd中的任何盘符使用node命令
	node -v 查看node的版本号 显示版本号代表Node安装成功
	如何运行文件：node+空格+鼠标拖拽文件进cmd+回车（拖拽时要注意文件内的相对文件路径）
	
	$ 是linux系统中普通用户的表示符号
	
	此时你拥有了第二个js运行环境，第一个是浏览器，第二个是node
	
	win10 win8 不允许在cmd中 cd d: 从c盘到d盘   cd   => change directory
	
	tab键可以自动补全，再按一次会出现新的补全结果
	
3，
	sync 同步
	async 异步
	
4，
	nodejs 没有服务器架构
	不用建设在任何服务器软件之上
	
	nodejs 没有根目录的概念
	
5，
	res.end() end里必须是一个字符串
	
	let http = require('http');
	let a = 0;
	
	http.createServer(function(req,res){
		a++;
		res.end(a.toString());
	}).listen(3000);
	我们发现全班同学共享一个a，每个人访问的时候都是看到别人已经刷过的a，a的值越来越高
	nodejs是单线程，如果程序有错误，唯一的node进程将停止，将会导致所有人无法访问
	所以对于node程序要求有极高的鲁棒性
	鲁棒性是指程序能够判断输入是否合乎规范要求,并对不符合要求的输入予以合理的处理
	
	es6就是es2016，很巧合，第6个版本就是2016年出现的，但以后都用年份，因为一年更新一次
	nodejs 中拥有js的所有语言核心语法，甚至拥有所有es2016所有新语法
	nodejs没有所有BOM的东西，比如window对象，window对象的一切函数也没有，计时器是有的
	
6,
	nodejs适合开发I/O多的业务，而不适合计算任务繁重的业务
	数学计算一多，单线程就会应接不暇
	
	只要I/O越多，nodejs宏观上越并行
	计算越多，nodejs宏观上越不能并行，网页打开速度越慢
	
	多线程程序：cpu经常会等待I/O结束，cpu的性能白白消耗
	单线程程序：当并行极大的时候，cpu理论上计算能力是100%
	
	因为nodejs想在破的机器上也能够高效运行，所以剑走偏锋采用了单线程的模式，
	既然单线程就必须异步I/O
	
	当在访问数据库数据的时候，需要一段较长的时间，在传统的处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码，也就是说，I/O阻塞了代码的执行，极大的降低了程序的执行效率
	由于nodejs中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率
	当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数，为了处理异步I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理
	阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程，而非阻塞模式下，一个线程永远在执行计算操作，这个线程的cpu核心利用率永远是100%，所以，这是一种特别有哲理的解决方案，与其人多，但是好多人闲着，还不如一个玩命，玩死里干活儿
	
	
	Node.js 是没有真实物理文件映射关系的，这叫做顶层路由设计。能够制作顶层路由
	设计的语言比较流行的仅有node和python
	
	res.end('') 表示结束输出流，让网页小菊花停止转动
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	