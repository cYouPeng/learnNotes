1，
	library 库   jquery
	runtime 运行环境 node

	LTS 最新稳定版
	current 最新版

2，
	
	
	node.js 可以在任何操作系统上安装，底层都是chrome v8 引擎 使用c++开发
	
	cmd commond的简写
	系统的环境变量中的path值，使得我们可以在cmd中的任何盘符使用node命令
	node -v 查看node的版本号 显示版本号代表Node安装成功
	如何运行文件：node+空格+鼠标拖拽文件进cmd+回车（拖拽时要注意文件内的相对文件路径）
	
	$ 是linux系统中普通用户的表示符号
	
	此时你拥有了第二个js运行环境，第一个是浏览器，第二个是node
	
	win10 win8 不允许在cmd中 cd d: 从c盘到d盘   cd   => change directory
	
	tab键可以自动补全，再按一次会出现新的补全结果
	
3，
	sync 同步
	async 异步
	
4，
	nodejs 没有服务器架构
	不用建设在任何服务器软件之上
	
	nodejs 没有根目录的概念
	
5，
	res.end() end里必须是一个字符串
	
	let http = require('http');
	let a = 0;
	
	http.createServer(function(req,res){
		a++;
		res.end(a.toString());
	}).listen(3000);
	我们发现全班同学共享一个a，每个人访问的时候都是看到别人已经刷过的a，a的值越来越高
	nodejs是单线程，如果程序有错误，唯一的node进程将停止，将会导致所有人无法访问
	所以对于node程序要求有极高的鲁棒性
	鲁棒性是指程序能够判断输入是否合乎规范要求,并对不符合要求的输入予以合理的处理
	
	es6就是es2016，很巧合，第6个版本就是2016年出现的，但以后都用年份，因为一年更新一次
	nodejs 中拥有js的所有语言核心语法，甚至拥有所有es2016所有新语法
	nodejs没有所有BOM的东西，比如window对象，window对象的一切函数也没有，计时器是有的
	
6,
	nodejs适合开发I/O多的业务，而不适合计算任务繁重的业务
	数学计算一多，单线程就会应接不暇
	
	只要I/O越多，nodejs宏观上越并行
	计算越多，nodejs宏观上越不能并行，网页打开速度越慢
	
	多线程程序：cpu经常会等待I/O结束，cpu的性能白白消耗
	单线程程序：当并行极大的时候，cpu理论上计算能力是100%
	
	因为nodejs想在破的机器上也能够高效运行，所以剑走偏锋采用了单线程的模式，
	既然单线程就必须异步I/O
	
	当在访问数据库数据的时候，需要一段较长的时间，在传统的处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码，也就是说，I/O阻塞了代码的执行，极大的降低了程序的执行效率
	由于nodejs中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率
	当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数，为了处理异步I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理
	阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程，而非阻塞模式下，一个线程永远在执行计算操作，这个线程的cpu核心利用率永远是100%，所以，这是一种特别有哲理的解决方案，与其人多，但是好多人闲着，还不如一个玩命，玩死里干活儿
	
	

	Node.js 是没有真实物理文件映射关系的，这叫做顶层路由设计。能够制作顶层路由
	设计的语言比较流行的仅有node和python
	
	res.end('') 表示结束输出流，让网页小菊花停止转动

	node.js 为单线程异步I/O，它要求有极高的鲁棒性，因为一旦有一条连接出错了，那么整个node服务就会停止，其它连接也会over
	
	在apache,nginx等服务器中，物理文件和url是一一对应的，比如
	D:\Learning Materials\前端学习笔记\node.js   通过这个url就能找到对应的文件
	
	但是在node.js中不行，Node中没有根目录的概念，url和物理文件并不是对应关系。在node中你需要给所有静态文件也加上路由
	eg: if(req.url === '/01.jpg'){
			fs.readFile('./01.jpg', (req, res) => {
				res.end(data);
			})
		}
		
		
	queryString属于req.url，但是hash不属于
	如果我想想要得到文件名的部分，不想要queryString，可以用正则提炼，但是太麻烦
	此时node提供了内置模块：url, path, querystring他们都可以服务于url的识别
	
	var url = require('url');
	var path = require('path')
	var querystring require('querystring')
	http.createServer((req, res) => {
		/**
		 *	根据url字符串输出一个对象，这个对象包括url的各个部分
			window下无法识别protocol,host等属性，Linux可以
			如果加上 url.parse(req.url,true) queryString部分将会变为一个对象
		 */
		var urlJson = url.parse(req.url)
		//得到文件路径
		var pathName = urlJson.pathName;
		//得到扩展名
		var extname = path.extname(pathName);
		//得到查询字符串
		var qs = urlJson.query;
		//转为查询对象，和url.parse加上true非常类似
		var qsjson = querystring.parse(qs)
		console.log(pathName,extname,qsjson)
		
	})
	
	
	var http = require('http');
	var fs = require('fs');
	var url = require('url');
	var path = require('path');
	var querystring = require('querystring');
	
	//准备一个映射关系对儿
	var mime = {
		".jpg": "image/jpeg",
		".jpeg": "image/jpeg",
		".gif": "image/gif",
		".png": "image/png",
		".html": "text/html;charset=UTF-8",
		".css": "text/css",
		".js": "application/x-javascript"		
	}
	var server = http.createServer((req,res) => {
		//得到用户读取什么，比如用户输入
		//http://127.0.0.1/myweb/0.jpg
		var pathname = url.parse(req.url).pathname
		//得到扩展名
		var extname = path.extname(pathname);
		//如果url中不存在扩展名，此时表示这是一个文件夹，此时自动补全/index.html
		if(!extname){
			//如果不是以/结尾，此时会造成浏览器识别图片路径层次有问题
			//比如http://127.0.0.1/b 和 http://127.0.0.1/b/ 不一样
			//同样的a.png，前者认为是同级目录下的图片，后者认为是b文件夹中的
			if(pathname.substr(-1) !== '/'){
				res.writeHead(302, {'Location': pathname + '/'})
			}
			pathname += "/index.html"
		}
		
		//读取这个文件
		fs.readFile('./myweb/' + pathname, (err,data) => {
			if(err){
				res.end('没有这个文件')
				return;
			}
			//检查是否属于我已知的mime类型
			if(mime.hasOwnProperty(extname)){
				res.setHeader("content-type",mime[extname])
			}
			res.setHeader()
			res.end(data)
		
		})
		
	})
	
	还有一个更大的问题，就是304的问题，304状态码 not modified。当文件没有改变的时候，服务器要发出304状态码，拒绝传输文件。我们的小程序没有这样的识别，我们也不解决了，因为确实太复杂，还要利用session和cookie保存镜像
	
	
11,复习
	请介绍Node.js  它是什么？
		Node.js 是一个 JavaScript 的运行环境，实际上就是利用 chrome v8 引擎，将它移植到了服务器上，用它开发服务器程序，可以提供HTTP服务
	
	node.js 的主要特点是什么？
		single thread 单线程     non_blocking I/O 非阻塞I/O    event driven 事件驱动
	
	这三个特点是相辅相成的，是必须的选择
	Node 为了在低硬件服务器条件下高并发，所以就减少内存消耗，剑走偏锋，选择了单线程
	必须要非阻塞I/O，因为你只有一个线程，你必须当A用户去I/O的时候，处理B业务的事情，B业务去I/O
	的时候，处理C的事情....A,B,C都有回调函数
	
	为了让A,B,C不乱套，每个人都进行合理调度，谁先来处理谁。你不能让B一直等待，处理C,D,E....所以node使用了
	一个机制叫做事件环，采用事件驱动来调度事件
	
	哪条语句是正确的，为什么？
	A语句：
		var data = fs.readFile('./test.txt');
	B语句：
		fs.readFile('./test.txt', function(err, data){
		
		});
	因为fs模块的 readFile 方法是异步方法，事实上 node 中的fs模块、mongodb模块基本上都是异步方法，一定要记住
	（当做规矩记住），异步函数不能通过return返回，不能通过等号来接受数据，必须通过回调函数传实参的模式来传输数据
	
	说说http模块，他有什么功能？有哪些方法？req和res各有什么属性和方法
	http模块用来提供http服务的，最常用的：
		http.createServer(function(req,res){
		});
	创建了一个服务器
	
	req对象封装了 http 上行请求的所有信息，常用属性 req.url, req.connection.remoteAddress, req.type等等
	res对象是服务器应该给出的下行响应，常用方法是res.write(), res.end(), res.setHeader()等等
	
	说说 NODEJS 的顶层路由设计
	apache 和 nodejs 的模式完全不一样
	apache天生有静态资源服务，但是nodejs不行，node必须使用路由清单给出明确的路由才行
		var pathname = url.parse(req.url).pathname;
		if(pathname === '/music'){
			res.end('音乐频道')
		}else if(pathname === '/news'){
			res.end('新闻频道');
		}else if(/^\/student\/[\d]{6}$/.test(pathname)){
			var xuehao = /^\/student\/([\d]{6})$/.exec(pathname)[1];
			res.end('学生频道,学号是'+xuehao)
		}else{
			res.end('错误的频道号');
		}
	
	常用 cmd 命令
		cls 清除屏幕内容
		cd c:\node_study  切换文件夹 cd 是 change directory
		mkdir newFolder 新建文件夹
		dir 列出当前目录的所有文件
		node 1.js 执行node命令
		shift + 右键  进入当前目录cmd
		当cmd挂起的时候，使用ctrl+c来打断
	
	powershell 可以让你在windows下使用linux命令
	
	
12，内置模块
	模块我们叫做 module，指的是一系列有关系的js的程序的集合
	后面我们学习mvc的m指的是model，模型，模型是实现最基本的算法的程序单位
	
	nodejs内置了很多模块，可以直接用require来进行引用，国际惯例是：你接受
	的名字最好和模块的一样
	var http = require('http');
	var qs = require('querystring');
	
	内置模块的引用使用require函数，require表示引用的意思
	引用是无条件的，不需要提前再引入什么
	引用是无路径的，在任何的目录下，都是通过require('http')来引用内置
	http模块，而require('./http');
	
	内置模块是node天生就有的，node.js手册就是按照模块来区分的
	我们后面还会学习一些模块，注意记忆里面的常用方法和属性，比如
	url.parse()
	querystring.parse()
	path.extname()
	
	
	
	
	